<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Warum Git besser als X ist</title>
	
	<link rel="stylesheet" href="blueprint/screen.css" type="text/css" media="screen, projection">
	<link rel="stylesheet" href="blueprint/print.css" type="text/css" media="print">
	<!--[if IE]><link rel="stylesheet" href="blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"></script>
	
	<style type="text/css">
		.header h1 { font-size: 3.0em; color: #666; }
		img { margin-bottom: 10px; }
		.text, p { font-size: 1.2em; margin-bottom: 10px; text-align: justify;}
		.intro { color: #444; }
		ul li { margin-top: 10px; }
		.section h2 { padding-left: 5px; background-color: #eee; cursor: pointer;}
		.section h2 a { color: #333; text-decoration:none; display: block; }
		.section { margin-bottom: 20px; }
		.contents { padding: 0 10px; }
		.args { float:right; }
		.lang { padding: 3px; font-weight: bold;}
		.section .lang { font-size: 0.8em; padding: 2px; font-weight: normal;}
		.svn { color: hsl(260,57%,24%); background: hsl(260,57%,83%) }
		.perforce { color: hsl(0,57%,24%); background: hsl(0,57%,83%) }
		.bzr { color: hsl(60,57%,24%); background: hsl(60,57%,83%) }
		.hg { color: hsl(190,57%,24%); background: hsl(190,57%,83%) }
		.sweet { color: #363; background: #beb; }
		.compare { color: #663; background: #eeb; }
		.help pre { font-size: 12px; }
		.help td { vertical-align: top; }
		code { font-size: 90%; }
		.footer { text-align: center; color: #663; background-color: #eea; padding: 10px;}
		.footer a { color: #440; }
	</style>
	
</head>

<body>

	<div class="container">

			<br/>
			
		<div class="span-24 header">
				<table width="100%">
					<tr><td>
	        <h1>Warum Git besser als X ist</h1>
					</td><td align="right">
						<div id="menu">
							<span class="lang hg">hg</span>
							<span class="lang bzr">bzr</span>
							<span class="lang svn">svn</span>
							<span class="lang perforce">perforce</span>
						</div>
						<img style="float: right" src="images/wherex.gif">
					</td></tr>
					</table>
		</div>

		<div class="span-24">
					<div class="text intro">
					    Diese Seite existiert weil ich in letzter Zeit oft Gitster gegen
					    Vorw&uuml;rfe von Fanboyismus, Mitl&auml;ufertums und "koolaid-Durst" verteidigen
					    musste. Darum hab ich eine Liste mit allen Gr&uuml;nden zusammengestellt
					    warum Leute von X zu Git wechseln, und warum du vielleicht auch wechseln
					    willst. Einfach auf einen Grund klicken um ihn anzuschauen.
					</div>
		</div>

			<br/>

		<div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

			<h2>
		  <a name="cheap-local-branching" href="#cheap-local-branching">Leichtgewichtige lokale Branches</a>
			</h2>
					<div class="contents">
						
						<div class="text">
						    Eines der wahrscheinlich am verlockendsten Features von Git,
						    welches es auch von so ziemlich allen anderen SCMs abhebt.
						    Es ist komplett unterschiedlich zu den anderen Modellen mit denen
						    ich es hier vergleiche, wo meistens ein kompletter Klon des
						    Repositories in einem neuen Verzeichnis als beste Branch-Strategie
						    empfohlen wird.
						</div>
						
						<div class="text">
						    Git arbeitet anders. Git erlaubt es dir mehrere lokale Branches
						    zu haben, die voneinander komplett unabh&auml;ngig sein k&ouml;nnen.
						    Erzeugen, Zusammenf&uuml;hren und L&ouml;schen von diesen Entwicklungsstr&auml;ngen
						    geht schnell vonstatten.
						</div>
						
						
						<div class="text">
						    Dadurch kann man Dinge machen wie :
							<ul>
								<li>Eine Idee in einem eigenen Branch ausprobieren, ein paar Commits
								    machen, zum Ursprungsbranch zur&uuml;ckswitchen, einen Patch einspielen,
								    wieder zum Ideenbranch wechseln, und ihn dann mergen.
								</li>
								<li>Einen Branch haben der all das beinhaltet was in Produktion gehen
								    soll, einen wo man neue Features zum austesten einspielt, und
								    mehrere kleinere f&uuml;r die t&auml;gliche Arbeit.
								</li>
								<li>F&uuml;r jedes neue Feature an dem du arbeitest einen eigenen
								    Branch erzeugen, damit du nahtlos zwischen ihnen wechseln
								    kannst ohne sich ins Gehege zu kommen, und sie dann einfach
								    zu l&ouml;schen wenn sie in den Hauptbranch eingespielt wurden.
								</li>
								<li>Ein Experiment auf einem Branch ausprobieren, entdecken dass es
								    nicht funktioniert, und ihn einfach zu l&ouml;schen - ohne das jemand
								    anders diesen Branch jemals zu Gesicht bekommt (auch wenn du
								    andere Branches in der Zwischenzeit gepusht hast).
								</li>
							</ul>
						</div>
						
						<img src="images/branches.png">
						
						<div class="text">
						    Wichtig: Wenn du zu einem entfernten Repository pushst, musst du
						    <em>nicht</em> alle deine lokalen Branches pushen. Du kannst auch
						    nur einen Branch ver&ouml;ffentlichen, und die anderen lokal lassen.
						    Das gibt dir die Freiheit neue Ideen auszuprobieren ohne dir
						    dar&uuml;ber Gedanken zu machen wie und wo du sie mit anderen Branches
						    zusammenf&uuml;hrst, oder sie mit anderen Leuten teilst.
						</div>
						
						<div class="text">
						    Du <em>kannst</em> Wege finden all das auch mit anderen Systemen zu machen,
						    aber das bedeutet meistens mehr Arbeit und h&ouml;here Fehleranf&auml;lligkeit. Git
						    macht diesen Prozess unglaublich einfach und es &auml;ndert die Arbeitsweise
						    der meisten Entwickler wenn sie Git lernen.
						</div>
						
						<!-- TODO : (short screencast showing the awesomeness of git branches) -->
						<!-- TODO : (show tweets somehow) -->

						<div class="tweets">
							<img alt='jamis twitter' width="300" src="http://twictur.es/i/1022811017.gif">
							<img alt='trevorturk twitter' width="300" src="http://twictur.es/i/1022886570.gif">
							<img alt='thillerson twitter' width="300" src="http://twictur.es/i/1022842917.gif">
							<img alt='boblmartens twitter' width="300" src="http://twictur.es/i/1022818467.gif">
							<img alt='mathie twitter' width="300" src="http://twictur.es/i/1022816942.gif">
						</div>
					</div>
		</div>
				
		<div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			<h2>
				<a name="everything-is-local" href="#everything-is-local">Alles ist lokal</a>
			</h2>
					<div class="contents">	

						<div class="text">
						    Grunds&auml;tzlich arbeiten alle dezentralen SCMs lokal, aber
						    in meiner Erfahrung ist das bei Git noch mehr der Fall.
						    Nur wenige Kommandos ausser 'fetch', 'pull' und 'push'
						    nehmen mit der Aussenwelt Kontakt auf, meistens wird nur
						    die Festplatte beansprucht.
						</div>

						<div class="text">
						    Das macht nicht nur die meisten Operationen um einiges schneller
						    als du es vielleicht gew&ouml;hnt bist, aber es erlaubt dir auch
						    komplett offline zu arbeiten. Das klingt jetzt vielleicht nicht
						    sehr aufregend, aber ich bin immer wieder erstaunt wie oft ich
						    eigentlich offline arbeiten muss. Die F&auml;higkeit neue Branches
						    anlegen oder zusammenf&uuml;hren zu k&ouml;nnen oder die Geschichte des
						    Projektes anzusehen w&auml;hrend ich im Flugzeug oder im Zug sitze
						    ist sehr produktiv.
						</div>
						
						<center><img width="500px" src="images/local-remote.png"></center>

						<div class="text">
						    Selbst in Mercurial nehmen oft genutzte Kommandos wie 'incoming'
						    und 'outgoing' Kontakt mit dem Server auf, w&auml;hrend man in Git mit
						    einem 'fetch' alle Daten holen kann bevor man offline geht, und
						    dann Vergleiche, Merges oder History mit den Daten machen kann,
						    die schon auf dem Server sind aber noch nicht in den lokalen Branches.
						</div>
												
						<div class="text">
						    Das bedeutet dass es sehr einfach ist Kopien nicht nur von
						    den eigenen Branches zu haben, sondern auch denen von jedem
						    anderen der mit dir im Git-Repository arbeitet, ohne dass
						    du dein eigenes Zeug durcheinander bringen musst.
						</div>
						
					</div>
		</div>
		
		  <div class="span-24 section">
					<div class="args">
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			
			<h2>
		  <a name="git-is-fast" href="#git-is-fast">Git ist Schnell</a>
			</h2>
	
					<div class="contents">
						<div class="text">
						    Git ist schnell. Jeder, selbst Hardcore-Benutzer anderer SCMs,
						    geben generell Git diesen Titel. Verglichen mit SVN und Perforce
						    ist das weil beinahe alle Operationen lokal passieren. Aber selbst
						    verglichen mit anderen verteilten SCMs ist Git ziemlich schnell.
						</div>
					
						<div class="text">
						    Ein Grund ist das Git dazu gebaut wurde um am Linux-Kernel zu
						    arbeiten, wodurch es von Beginn an effektiv mit grossen
						    Repositories umgehen musste.
						    Ein anderer Grund ist das Git in C geschrieben ist, und noch
						    ein weiterer Grund ist dass die prim&auml;ren Entwickler in meiner
						    Erfahrung sich sehr, sehr viel damit besch&auml;ftigen.
						</div>

						<div class="text">
						    Im folgenden sind ein paar Benchmarks die ich mit drei Kopien
						    des Django Sourcecodes in 3 verschiedenen SCMs gemacht habe:
						    Git, Mercurial und Bazaar. Ich hab einiges von dem auch in SVN
						    getestet, aber glaub mir, es ist langsamer - nimm die Zahlen von
						    Bazaar und f&uuml;ge Netzwerklatenz hinzu...
						</div>
						
						<table>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:2,5,60&chds=0,60&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Init">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:85,3,23&chds=0,100&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Add">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:45,194,1474&chds=0,1474&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Status">
						
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:5,21,142&chds=0,142&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Diff">
						</td><td rowspan="2">
							<img src="http://chart.apis.google.com/chart?cht=bvg&chs=190x275&chd=t:1,123,390|11,946,820&chds=0,1210&chxt=x&chco=4d89f9,c6d9fd&chl=git|hg|bzr&chtt=Branching">
						</td></tr>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:5,120,189&chds=0,230&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Tag">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:7,26,90&chds=0,90&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Log">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:124,125,230&chds=0,230&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Commit (Lg)">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:8,51,113&chds=0,113&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Commit (Sm)">
						</td></tr>
						</table>
						
						<div class="text">
						    Das Endresultat war das Git in allem ausser dem Hinzuf&uuml;gen von neuen
						    Dateien am schnellsten war (Mercurial liegt bei sehr grossen Commits
						    gleichauf, aber der Commit mit dem ich getestet habe war so gross dass
						    es unwahrscheinlich ist dass du jemals etwas &auml;hnlich grosses
						    comitten wirst - normale Commits sind viel schneller in Git)
						</div>
						
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
							</tr>
							<tr>
								<th>Init</th>
								<td class="sweet">0.024s</td>
								<td>0.059s</td>
								<td>0.600s</td>
							</tr>
							<tr>
								<th>Add</th>
								<td>8.535s</td>
								<td class="sweet">0.368s</td>
								<td>2.381s</td>
							</tr>
							<tr>
								<th>Status</th>
								<td class="sweet">0.451s</td>
								<td>1.946s</td>
								<td>14.744s</td>
							</tr>
							<tr>
								<th>Diff</th>
								<td class="sweet">0.543s</td>
								<td>2.189s</td>
								<td>14.248s</td>
							</tr>
							<tr>
								<th>Tag</th>
								<td class="sweet">0.056s</td>
								<td>1.201s</td>
								<td>1.892s</td>
							</tr>
							<tr>
								<th>Log</th>
								<td class="sweet">0.711s</td>
								<td>2.650s</td>
								<td>9.055s</td>
							</tr>
							<tr>
								<th>Commit (Large)</th>
								<td class="sweet">12.480s</td>
								<td>12.500s</td>
								<td>23.002s</td>
							</tr>
							<tr>
								<th>Commit (Small)</th>
								<td class="sweet">0.086s</td>
								<td>0.517s</td>
								<td>1.139s</td>
							</tr>
							<tr>
								<th>Branch (Cold)</th>
								<td class="sweet">1.161s</td>
								<td>94.681s</td>
								<td>82.249s</td>
							</tr>
							<tr>
								<th>Branch (Hot)</th>
								<td class="sweet">0.070s</td>
								<td>12.300s</td>
								<td>39.411s</td>
							</tr>
						</table>
					
						<div class="text">
						    Die kalten und warmen Branching-Werte sind die Zahlen f&uuml;r das
						    erste und das zweite Mal wo ich einen neuen Branch erstellte -
						    die zweite Zahl ist ein neuer Branch mit einem warmen
						    Festplatten-Cache.
						</div>

						<div class="text">
						    Es sollte bemerkt werden dass obwohl die 'add'-Werte um einiges
						    langsamer sind, dass dies f&uuml;r eine wirklich massive 'add'-Operation
						    war - &uuml;ber 2000 Dateien. F&uuml;r den Großteil was die meisten Leute
						    t&auml;glich machen werden sind 'add'-Operationen in allen diesen Systemen
						    innerhalb eines Bruchteils einer Sekunde erledigt. Alle anderen
						    Operationen die hier getestet wurden (ausser dem grossen Commit
						    vielleicht) sind ein Hinweis auf die Dinge die man vielleicht
						    auch t&auml;glich macht.
						</div>
					
					
					<div class="text">
					    Die Zahlen sind nicht wirklich schwer zum nachmachen, einfach das Django-Projekt
					    in jedem dieser Systeme klonen und die gleichen Kommandos in jedem ausprobieren.
						<ul>
							<li><code>git clone git://github.com/brosner/django.git dj-git</code></li>
							<li><code>hg clone http://hg.dpaste.com/django/trunk dj-hg</code></li>
							<li><code>bzr branch lp:django dj-bzr</code></li>
							<li><code>svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn</code></li>
						</ul>
					</div>
					
				</div>
					
					
		</div>
	
		  <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
					</div>
			
			<h2>
		  <a name="git-is-small" href="#git-is-small">Git ist klein</a>
			</h2>
	
					<div class="contents">
						<div class="text">
						    Git ist wirklich gut darin Platz zu sparen. Dein Git-Verzeichnis
						    wird (im Allgemeinen) kaum gr&ouml;sser als ein SVN checkout sein -
						    in manchen F&auml;llen sogar kleiner (anscheinend kann viel in diese
						    .svn Verzeichnisse gepackt werden).
						</div>
					
						<div class="text">
						    Die folgenden Zahlen wurden von den Klonen des Django-Projekts
						    genommen, in jedem der semi-offiziellen gespiegelten Git-Repositories
						    am gleichen Zeitpunkt in dessen History.
						</div>
					
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
								<th>Bzr*</th>
								<th>SVN</th>
							</tr>
							<tr>
								<td>Repo Alone</td>
								<td class="sweet">24M</td>
								<td>34M</td>
								<td>45M</td>
								<td>89M</td>
								<td></td>
							</tr>
							<tr>
								<td>Entire Directory</td>
								<td class="compare">43M</td>
								<td>53M</td>
								<td>64M</td>
								<td>108M</td>
								<td class="compare">61M</td>
							</tr>
						</table>
						
						<div class="text"><small>
						    * der zweite Bzr-Wert kam nach dem Ausf&uuml;hren von 'bzr pack' zustande,
						    nachdem ich dachte dass es das Repository kleiner machen w&uuml;rde, aber
						    aus irgend einem Grund viel, viel gr&ouml;sser machte.
						</small></div>
						
					</div>
		</div>

		<div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
		
			<h2>
		  <a name="the-staging-area" href="#the-staging-area">Die Staging Area</a>
			</h2>
					<div class="contents">
						<div class="text">
						    Im Gegensatz zu anderen Systemen hat git etwas namens "staging area"
						    oder "Index". Das ist eine Zwischenschicht in dem du deinen
						    n&auml;chsten Commit genau so vorbereiten kannst dass er so aussieht
						    wie du ihn haben willst.
						</div>
						<div class="text">
						    <!-- TODO: Gute Übersetzung f&uuml;r "Staging Area" finden -->
						    Das coole an der Staging Area, und was Git von diesen anderen
						    Werkzeugen unterscheidet, ist dass du ganz einfach nur einzelne
						    Dateien in die Staging Area geben und diese dann ganz
						    einfach commiten kannst ohne die anderen modifizierten Dateien
						    in deinem Arbeitsverzeichnis mit comitten zu m&uuml;ssen. Oder jede
						    Datei einzeln auf der Kommandozeile angeben zu m&uuml;ssen wenn du
						    einen Commit erstellst
						</div>
						<center><img src="images/index1.png"></center>
						
						<div class="text">
						    Das erlaubt es dir auch nur Teile der Modifikationen in die Staging
						    Area zu geben. Du kannst zum Beispiel nur die &Auml;nderungen im oberen
						    Teil der Datei an der du gerade hackst in die Staging Area geben,
						    aber nicht die &Auml;nderungen im unteren Teil.
						</div>

						<div class="text">
						    Git macht es nat&uuml;rlich auch einfach dieses Feature zu ignorieren
						    wenn du diese feine Kontrolle nicht ben&ouml;tigst - einfach ein '-a'
						    an das Commit-Kommando anh&auml;ngen.
						</div>
						
						<center><img src="images/index2.png"></center>
					</div>
		</div>

		<div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

			<h2>
		  <a name="distributed" href="#distributed">Verteilt</a>
			</h2>

					<div class="contents">

					  <div class="text">
					    Eines der coolsten Features eines jeden verteilten SCMs, inklusive Git, ist dass es
					    verteilt ist. Das bedeutet dass man statt einem "checkout" des aktuellsten Stand des
					    Source Codes einen kompletten "Klon" des ganzen Repositories macht.
					  </div>
					  <div class="text">
					    Dadurch hat jeder User essentiell ein komplettes Backup des Hauptservers,
					    selbst wenn man einen zentralisierten Arbeitsablauf verwendet, von dem 
					    jedes dazu verwendet kann den Hauptserver zu ersetzen falls dieser wegen eines
					    Crash oder Korruption ausfallen sollte. Es gibt deshalb mit Git grunds&auml;tzlich
					    keinen "Single Point of Failure" mehr, ausser man hat nur einen Punkt.
					  </div>
					  
					  <div class="text">
					    Das macht es aber nicht langsamer. Im Durchschnitt ist ein SVN Checkout schneller als
					    jedes der SCMs, aber nicht um viel. Des weiteren war Git das schnellste von allen DSCMs
					    in meinen Tests.
					  </div>

						<table>
							<tr><td>
								<img src="http://chart.apis.google.com/chart?cht=bvs&chs=200x150&chd=t:120,144,311,64&chds=0,320&chco=4d89f9&chl=git|hg|bzr|svn&chtt=Clone">
							</td><td width="80%">
								<table>
									<tr>
										<th>Git</th>
										<td class="sweet">1m 59s</td>
									</tr>
									<tr>
										<th>Hg</th>
										<td>2m 24s</td>
									</tr>
									<tr>
										<th>Bzr</th>
										<td>5m 11s</td>
									</tr>
									<tr>
										<th>SVN</th>
										<td>1m 4s</td>
									</tr>
								</table>
							</td></tr>
						</table>
						
					</div>
		</div>
	
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>
		
		<h2>
		<a name="any-workflow" href="#any-workflow">Beliebige Arbeitsabl&auml;ufe</a>
		</h2>

				<div class="contents">
					
					<div class="text">
					    Eines der erstaunlichen Dinge ist dass man wegen Gits verteilter
					    Natur und tollen Branching-System relativ einfach
					    so ziemlich jeden beliebigen Arbeitsablauf realisieren kann den
					    man haben will.
					</div>
					
					<h3>Arbeitsablauf im Subversion-Stil</h3>
					

					<div class="text">
					    Ein sehr gebr&auml;uchlicher Arbeitsablauf in Git, insbesondere von
					    Leuten die gerade den Übergang von einem zentralisierten System
					    machen, ist der zentralisierte Arbeitsablauf. Git erlaubt es einem
					    nicht seine Commits zu pushen wenn jemand anderes seit dem letzen
					    fetch gepusht hat, weshalb das zentralisierte Modell, wo alle
					    Entwickler zu einem zentralen Server pushen, ohne Probleme
					    funktioniert.
					</div>
					
					<center><img src="images/workflow-a.png"></center><br/>
					
					<h3>Arbeitsablauf f&uuml;r Integrationsmanager</h3>

					<div class="text">
					    Ein anderer gebr&auml;uchlicher Arbeitsablauf ist der eines
					    Integrationsmanagers - einer einzelnen Person die
					    in ein 'geweihtes' Repository committet, von dem dann die
					    anderen Entwickler klonen, ihre &Auml;nderungen in ihre eigenen,
					    unabh&auml;ngigen Repositories pushen, und dann den Manager bitten
					    ihre &Auml;nderungen zu ziehen. Diese Art von Entwicklungsmodell sieht
					    man oft in Open Source oder GitHub Repositories.
					</div>

					<center><img src="images/workflow-b.png"></center><br/>

					<h3>Arbeitsablauf im Diktator und Leutnant Stil</h3>

					<div class="text">
					    F&uuml;r massive Projekte empfiehlt sich ein Arbeitsablauf wie er im
					    Linux Kernel stattfindet, wo gewisse Leute f&uuml;r gewisse Subsysteme
					    verantwortlich sind ('Leutnants'), und alle &Auml;nderungen die dieses
					    Subsystem betreffen in ihr Repository mergen. Dann kann ein
					    anderer Integrator (der 'Diktator') nur von seinen Leutnants
					    &Auml;nderungen ziehen und integrieren, die er dann in sein 'geweihtes'
					    Repository pusht, von dem dann jeder klonen oder updaten kann.
					</div>

					<center><img src="images/workflow-c.png"></center><br/>
					
					<div class="text">
					    Git ist sehr flexibel was den gew&uuml;nschten Arbeitsablauf
					    angeht. Man kann also seinen Arbeitsablauf ganz nach seinen
					    W&uuml;nschen gestalten.
					</div>
					
				</div>
		</div>
	
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang hg">hg</span>
					<span class="lang bzr">bzr</span>
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>

		<h2>
		<a name="github" href="#github">GitHub</a>
		</h2>
				
				<div class="contents">

					<img style="float:right; padding:10px" src="images/octocat.png">

					<div class="text">
					    Ich <em>mag</em> hier parteiisch sein, nachdem ich f&uuml;r
					    <a href="http://github.com">GitHub</a> arbeite, aber
					    ich habe diese Sektion dennoch hinzugef&uuml;gt nachdem so
					    viele Leute GitHub als speziellen Grund angef&uuml;hrt haben
					    weshalb sie Git ausgew&auml;hlt haben.
					</div>

					<div class="text">
					    GitHub ist ein Grund f&uuml;r viele Leute Git zu verwenden, da es mehr
					    wie ein soziales Netzwerk ist als eine einfache Code-Hosting Seite.
					    Es ist leicht andere Personen oder Projekte zu finden die &auml;hnlich
					    zu den Dingen sind die sie tuen, und k&ouml;nnen einfach forken und
					    eigene &Auml;nderungen beitragen. Dies erzeugt eine sehr lebhafte
					    Gemeinschaft um Git und die Projekte in denen es verwendet wird.
					</div>
					
					<div class="text">
					    Es gibt auch andere Services, f&uuml;r Git und die anderen SCMs,
					    aber wenige sind so Benuzterorientiert oder sozial, und keines
					    hat auch nur ann&auml;hernd soviele Benutzer. Dieser soziale Aspekt
					    von GitHub ist ein M&ouml;rderfeature, und das alles plus den obigen
					    Features machen das Arbeiten mit Git und GitHub eine grossartige
					    Kombination zum schnellen Entwickeln von Open Source Projekten.
					</div>

					<div class="text">
					    Diese Art der Gemeinschaft findet man einfach nicht in anderen SCMs.
					</div>
					
					<div class="tweets">
						<img alt='puls twitter' width="300" src="http://twictur.es/i/1022858126.gif">
						<img alt='twitter' width="300" src="http://twictur.es/i/1022857633.gif">
					</div>
				</div>
		</div>
	
	
			<!-- 
				OTHER IDEAS:
				* easy merging
				* easy server setup
				* non destructive
			-->

	
			<!-- GIT MYTHS -->
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang perforce">perforce</span>
				</div>
				
		<h2>
		<a name="easy-to-learn" href="#easy-to-learn">Einfach zu lernen</a>
		</h2>
		
				<div class="contents">
					<div class="text">
					    Dies war nicht immer wahr - in den fr&uuml;hen Lebensjahren von Git war
					    es nicht wirklich ein SCM als eine Ansammlung von Tools die es einem
					    erm&ouml;glichten mit einem versionierten Dateisystem in einer verteilten
					    Manier zu arbeiten. Heute ist der Kommando-Satz und Lernkurve von Git
					    ziemlich &auml;hnlich zu jedem anderen SCM, und sogar besser als manch
					    anderes.
					</div>

					<div class="text">
					    Nachdem es schwer ist ohne eine Studie etwas objektiv nachzuweisen,
					    zeige ich nur die Unterschiede zwischen den Standardausgaben der
					    Hilfekommandos von Mercurial und Git. Ich habe Kommandos hervorgehoben
					    die in beiden Systemen gleich oder beinahe gleich funktionieren. (In
					    Mercurial bekommt man eine Liste mit ca. 40 Kommandos wenn man
					    'hg help' tippt.)
					</div>
				
					<table class="help">
						<tr><td valign="top">
							
<h3>Mercurial Help</h3>
<pre>
<span class="compare">add</span>		add the specified files ...
<span class="compare">annotate</span>	show changeset informati...
<span class="compare">clone</span>		make a copy of an existi...
<span class="compare">commit</span>		commit the specified fil...
<span class="compare">diff</span>		diff repository (or sele...
export	   dump the header and diff...
<span class="compare">init</span>		create a new repository ...
<span class="compare">log</span>		show revision history of...
<span class="compare">merge</span>		merge working directory ...
parents	   show the parents of the ...
<span class="compare">pull</span>		pull changes from the sp...
<span class="compare">push</span>		push changes to the spec...
<span class="compare">remove</span>		remove the specified fil...
serve	   export the repository vi...
<span class="compare">status</span>		show changed files in th...
update	   update working directory
</pre>

					</td><td valign="top">
						
<h3>Git Help</h3>
<pre>
<span class="compare">add</span>		Add file contents to the index
<span class="compare">bisect</span>		Find the change that introduce...
<span class="compare">branch</span>		List, create, or delete branches
checkout   Checkout a branch or paths to ...
<span class="compare">clone</span>		Clone a repository into a new ...
<span class="compare">commit</span>		Record changes to the repository
<span class="compare">diff</span>		Show changes between commits, ...
fetch	   Download objects and refs from...
grep	   Print lines matching a pattern
<span class="compare">init</span>		Create an empty git repository
<span class="compare">log</span>		Show commit logs
<span class="compare">merge</span>		Join two or more development h...
mv		   Move or rename a file, a direc...
<span class="compare">pull</span>		Fetch from and merge with anot...
<span class="compare">push</span>		Update remote refs along with ...
rebase	   Forward-port local commits to ...
reset	   Reset current HEAD to the spec...
<span class="compare">rm</span>			Remove files from the working ...
show	   Show various types of objects
<span class="compare">status</span>		Show the working tree status
<span class="compare">tag</span>		Create, list, delete or verify...
</pre>	
				</td></tr>
				</table>
				
				<div class="text">
				    Vor Git 1.6 waren alle Git Kommandos im ausf&uuml;hrbaren Pfad, was
				    f&uuml;r einige Leute sehr verwirrend war. Obwohl Git noch immer all
				    diese Kommandos kennt, ist das einzige Kommando das noch im
				    ausf&uuml;hrbaren Pfad ist 'git'. Also, wenn man sich Mercurial und Git
				    ansieht, dann hat Git ein beinahe identisches Kommando-Satz und
				    Hilfe-System - es gibt also von einer angehenden UI Sicht kaum
				    Unterschiede.
				</div>
				
				<div class="text">
				    Heutzutage ist es ziemlich schwer zu argumentieren das Mercurial oder
				    Bazaar leichter zu lernen sind als Git.
				</div>
				
				</div>
				
		</div>
	
	
		<!-- 
			THINGS GIT IS STILL NOT GOOD AT 
			* windows (all)
			* large files (svn)
		-->

		<br/>
		
	<div class="span-24 footer">
			Diese Seite ist von <a href="http://github.com/schacon">Scott Chacon</a> gebaut worden, einem <a href="http://github.com">GitHubber</a>.<br/>
			Übersetzung ins Deutsche durch <a href="http://github.com/cypher">Markus Prinz</a>.<br/>
			Wenn du aus gutem Grund mit irgend etwas auf dieser Seite nicht einverstanden bist, schreibe bitte eine
			<a href="mailto:schacon@gmail.com">email an mich</a> (in Englisch) damit ich es beheben kann.<br/>
			Der Sourcecode f&uuml;r diese Seite ist <a href="http://github.com/schacon/whygitisbetter">auf GitHub</a> -
			Patches sind jederzeit willkommen wenn du Verbesserungen hast.
		</div>

	</div>

<script>
	$(function() {
		$('.section > .contents').hide();
		$('.contents > .tweets').hide();
		$('.section > h2').click(function() {
			$(this).next().slideToggle();
		})
		
		if (document.location.hash) {
		  $('.section > h2 > a[name=' + document.location.hash.substring(1) + ']').parent('h2').click()
		}
	})
</script>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-82337-13");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

