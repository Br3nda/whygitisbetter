<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Why Git is Better Than X</title>
	
	<link rel="stylesheet" href="blueprint/screen.css" type="text/css" media="screen, projection">
	<link rel="stylesheet" href="blueprint/print.css" type="text/css" media="print">
	<!--[if IE]><link rel="stylesheet" href="blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"></script>
	
	<style type="text/css">
		.header h1 { font-size: 3.5em; color: #666; }
		img { margin-bottom: 10px; }
		.text, p { font-size: 1.2em; margin-bottom: 10px; text-align: justify;}
		.intro { color: #444; }
		ul li { margin-top: 10px; }
		.section h2 { padding-left: 5px; background-color: #eee; cursor: pointer;}
		.section h2 a { color: #333; text-decoration:none; display: block; }
		.section { margin-bottom: 20px; }
		.contents { padding: 0 10px; }
		.args { float:right; }
		.lang { padding: 3px; font-weight: bold;}
		.section .lang { font-size: 0.8em; padding: 2px; font-weight: normal;}
		.svn { color: hsl(260,57%,24%); background: hsl(260,57%,83%) }
		.perforce { color: hsl(0,57%,24%); background: hsl(0,57%,83%) }
		.bzr { color: hsl(60,57%,24%); background: hsl(60,57%,83%) }
		.hg { color: hsl(190,57%,24%); background: hsl(190,57%,83%) }
		.sweet { color: #363; background: #beb; }
		.compare { color: #663; background: #eeb; }
		.help pre { font-size: 12px; }
		.help td { vertical-align: top; }
		code { font-size: 90%; }
		.footer { text-align: center; color: #663; background-color: #eea; padding: 10px;}
		.footer a { color: #440; }
	</style>
	
</head>

<body>

	<div class="container">

			<br/>
			
		<div class="span-24 header">
				<table width="100%">
					<tr><td>
				<h1>Why Git is Better than X</h1>
					</td><td align="right">
						<div id="menu">
							<span class="lang hg">hg</span>
							<span class="lang bzr">bzr</span>
							<span class="lang svn">svn</span>
							<span class="lang perforce">perforce</span>
						</div>
						<img style="float: right" src="images/wherex.gif">
					</td></tr>
					</table>
		</div>

		<div class="span-24">
					<div class="text intro">
					    Diese Seite existiert weil ich in letzter Zeit oft Gitster gegen
					    Vorw&uuml;rfe von Fanboyismus, Mitläufertums und koolaid-Durst verteidigen
					    musste. Darum hab ich eine Liste mit allen Gr&uuml;nden zusammengestellt
					    warum Leute von X zu Git wechseln, und warum du vielleicht auch wechseln
					    willst. Einfach auf einen Grund klicken um ihn anzuschauen.
					</div>
		</div>

			<br/>

		<div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

			<h2>
		  <a name="cheap-local-branching" href="#cheap-local-branching">Leichtgewichtige lokale Branches</a>
			</h2>
					<div class="contents">
						
						<div class="text">
						    Eines der wahrscheinlich am verlockendsten Features von Git,
						    welches es auch von so ziemlich allen anderen SCMs abhebt.
						    Es ist komplett unterschiedlich zu den anderen Modellen mit denen
						    ich es hier vergleiche, wo meistens ein kompletter Klon des
						    Repositories in einem neuen Verzeichnis als beste Branch-Strategie
						    empfohlen wird.
						</div>
						
						<div class="text">
						    Git arbeitet anders. Git erlaubt es dir mehrere lokale Branches
						    zu haben, die voneinander komplett unabhängig sein können.
						    Erzeugen, Zusammenführen und Löschen von diesen Entwicklungssträngen
						    geht schnell vonstatten.
						</div>
						
						
						<div class="text">
						    Dadurch kann man Dinge machen wie :
							<ul>
								<li>Eine Idee in einem eigenen Branch ausprobieren, ein paar Commits
								    machen, zum Ursprungsbranch zurückswitchen, einen Patch einspielen,
								    wieder zum Ideenbranch wechseln, und ihn dann mergen.
								</li>
								<li>Einen Branch haben der all das beinhaltet was in Produktion gehen
								    soll, einen wo man neue Features zum austesten einspielt, und
								    mehrere kleinere für die tägliche Arbeit.
								</li>
								<li>Für jedes neue Feature an dem du arbeitest einen eigenen
								    Branch erzeugen, damit du nahtlos zwischen ihnen wechseln
								    kannst ohne sich ins Gehege zu kommen, und sie dann einfach
								    zu löschen wenn sie in den Hauptbranch eingespielt wurden.
								</li>
								<li>Ein Experiment auf einem Branch ausprobieren, entdecken dass es
								    nicht funktioniert, und ihn einfach zu löschen - ohne das jemand
								    anders diesen Branch jemals zu Gesicht bekommt (auch wenn du
								    andere Branches in der Zwischenzeit gepusht hast).
								</li>
							</ul>
						</div>
						
						<img src="images/branches.png">
						
						<div class="text">
						    Wichtig: Wenn du zu einem entfernten Repository pushst, musst du
						    <em>nicht</em> alle deine lokalen Branches pushen. Du kannst auch
						    nur einen Branch veröffentlichen, und die anderen lokal lassen.
						    Das gibt dir die Freiheit neue Ideen auszuprobieren ohne dir
						    darüber Gedanken zu machen wie und wo du sie mit anderen Branches
						    zusammenführst, oder sie mit anderen Leuten teilst.
						</div>
						
						<div class="text">
						    Du <em>kannst</em> Wege finden all das auch mit anderen Systemen zu machen,
						    aber das bedeutet meistens mehr Arbeit und höhere Fehleranfälligkeit. Git
						    macht diesen Prozess unglaublich einfach und es ändert die Arbeitsweise
						    der meisten Entwickler wenn sie Git lernen.
						</div>
						
						<!-- TODO : (short screencast showing the awesomeness of git branches) -->
						<!-- TODO : (show tweets somehow) -->

						<div class="tweets">
							<img alt='jamis twitter' width="300" src="http://twictur.es/i/1022811017.gif">
							<img alt='trevorturk twitter' width="300" src="http://twictur.es/i/1022886570.gif">
							<img alt='thillerson twitter' width="300" src="http://twictur.es/i/1022842917.gif">
							<img alt='boblmartens twitter' width="300" src="http://twictur.es/i/1022818467.gif">
							<img alt='mathie twitter' width="300" src="http://twictur.es/i/1022816942.gif">
						</div>
					</div>
		</div>
				
		<div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			<h2>
				<a name="everything-is-local" href="#everything-is-local">Alles ist lokal</a>
			</h2>
					<div class="contents">	

						<div class="text">
						    Grundsätzlich arbeiten alle dezentralen SCMs lokal, aber
						    in meiner Erfahrung ist das bei Git noch mehr der Fall.
						    Nur wenige Kommandos ausser 'fetch', 'pull' und 'push'
						    nehmen mit der Aussenwelt Kontakt auf, meistens wird nur
						    die Festplatte beansprucht.
						</div>

						<div class="text">
						    Das macht nicht nur die meisten Operationen um einiges schneller
						    als du es vielleicht gewöhnt bist, aber es erlaubt dir auch
						    komplett offline zu arbeiten. Das klingt jetzt vielleicht nicht
						    sehr aufregend, aber ich bin immer wieder erstaunt wie oft ich
						    eigentlich offline arbeiten muss. Die Fähigkeit neue Branches
						    anlegen oder zusammenführen zu können oder die History des
						    Projektes anzusehen während ich im Flugzeug oder im Zug sitze
						    ist sehr produktiv.
						</div>
						
						<center><img width="500px" src="images/local-remote.png"></center>

						<div class="text">
						    Selbst in Mercurial nehmen oft genutzte Kommandos wie 'incoming'
						    und 'outgoing' Kontakt mit dem Server auf, während man in Git mit
						    einem 'fetch' alle Daten holen kann bevor man offline geht, und
						    dann Vergleiche, Merges oder History mit den Daten machen kann,
						    die schon auf dem Server sind aber noch nicht in den lokalen Branches.
						</div>
												
						<div class="text">
						    Das bedeutet dass es sehr einfach ist Kopien nicht nur von
						    den eigenen Branches zu haben, sondern auch denen von jedem
						    anderen der mit dir im Git-Repository arbeitet, ohne dass
						    du dein eigenes Zeug durcheinander bringen musst.
						</div>
						
					</div>
		</div>
		
		  <div class="span-24 section">
					<div class="args">
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			
			<h2>
		  <a name="git-is-fast" href="#git-is-fast">Git ist Schnell</a>
			</h2>
	
					<div class="contents">
						<div class="text">
						    Git ist schnell. Jeder, selbst Hardcore-Benutzer anderer SCMs,
						    geben generell Git diesen Titel. Verglichen mit SVN und Perforce
						    ist das weil beinahe alle Operationen lokal passieren. Aber selbst
						    verglichen mit anderen verteilten SCMs ist Git ziemlich schnell.
						</div>
					
						<div class="text">
						    Ein Grund ist das Git dazu gebaut wurde um am Linux-Kernel zu
						    arbeiten, wodurch es von Beginn an effektiv mit grossen
						    Repositories umgehen musste.
						    Ein anderer Grund ist das Git in C geschrieben ist, und noch
						    ein weiterer Grund ist dass die primären Entwickler in meiner
						    Erfahrung sich sehr, sehr viel damit beschäftigen.
						</div>

						<div class="text">
						    Im folgenden sind ein paar Benchmarks die ich mit drei Kopien
						    des Django Sourcecodes in 3 verschiedenen SCMs gemacht habe:
						    Git, Mercurial und Bazaar. Ich hab einiges von dem auch in SVN
						    getestet, aber glaub mir, es ist langsamer - nimm die Zahlen von
						    Bazaar und füge Netzwerklatenz hinzu...
						</div>
						
						<table>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:2,5,60&chds=0,60&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Init">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:85,3,23&chds=0,100&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Add">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:45,194,1474&chds=0,1474&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Status">
						
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:5,21,142&chds=0,142&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Diff">
						</td><td rowspan="2">
							<img src="http://chart.apis.google.com/chart?cht=bvg&chs=190x275&chd=t:1,123,390|11,946,820&chds=0,1210&chxt=x&chco=4d89f9,c6d9fd&chl=git|hg|bzr&chtt=Branching">
						</td></tr>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:5,120,189&chds=0,230&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Tag">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:7,26,90&chds=0,90&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Log">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:124,125,230&chds=0,230&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Commit (Lg)">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:8,51,113&chds=0,113&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Commit (Sm)">
						</td></tr>
						</table>
						
						<div class="text">
						    Das Endresultat war das Git in allem ausser dem Hinzufügen von neuen
						    Dateien am schnellsten war (Mercurial liegt bei sehr grossen Commits
						    gleichauf, aber der Commit mit dem ich getestet habe war so gross dass
						    es unwahrscheinlich ist dass du jemals etwas ähnlich grosses
						    comitten wirst - normale Commits sind viel schneller in Git)
						</div>
						
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
							</tr>
							<tr>
								<th>Init</th>
								<td class="sweet">0.024s</td>
								<td>0.059s</td>
								<td>0.600s</td>
							</tr>
							<tr>
								<th>Add</th>
								<td>8.535s</td>
								<td class="sweet">0.368s</td>
								<td>2.381s</td>
							</tr>
							<tr>
								<th>Status</th>
								<td class="sweet">0.451s</td>
								<td>1.946s</td>
								<td>14.744s</td>
							</tr>
							<tr>
								<th>Diff</th>
								<td class="sweet">0.543s</td>
								<td>2.189s</td>
								<td>14.248s</td>
							</tr>
							<tr>
								<th>Tag</th>
								<td class="sweet">0.056s</td>
								<td>1.201s</td>
								<td>1.892s</td>
							</tr>
							<tr>
								<th>Log</th>
								<td class="sweet">0.711s</td>
								<td>2.650s</td>
								<td>9.055s</td>
							</tr>
							<tr>
								<th>Commit (Large)</th>
								<td class="sweet">12.480s</td>
								<td>12.500s</td>
								<td>23.002s</td>
							</tr>
							<tr>
								<th>Commit (Small)</th>
								<td class="sweet">0.086s</td>
								<td>0.517s</td>
								<td>1.139s</td>
							</tr>
							<tr>
								<th>Branch (Cold)</th>
								<td class="sweet">1.161s</td>
								<td>94.681s</td>
								<td>82.249s</td>
							</tr>
							<tr>
								<th>Branch (Hot)</th>
								<td class="sweet">0.070s</td>
								<td>12.300s</td>
								<td>39.411s</td>
							</tr>
						</table>
					
						<div class="text">
						    Die kalten und warmen Branching-Werte sind die Zahlen für das
						    erste und das zweite Mal wo ich einen neuen Branch erstellte -
						    die zweite Zahl ist ein neuer Branch mit einem warmen
						    Festplatten-Cache.
						</div>

						<div class="text">
						    Es sollte bemerkt werden dass obwohl die 'add'-Werte um einiges
						    langsamer sind, dass dies für eine wirklich massive 'add'-Operation
						    war - über 2000 Dateien. Für den Großteil was die meisten Leute
						    täglich machen werden sind 'add'-Operationen in allen diesen Systemen
						    innerhalb eines Bruchteils einer Sekunde erledigt. Alle anderen
						    Operationen die hier getestet wurden (ausser dem grossen Commit
						    vielleicht) sind ein Hinweis auf die Dinge die man vielleicht
						    auch täglich macht.
						</div>
					
					
					<div class="text">
					    Die Zahlen sind nicht wirklich schwer zum nachmachen, einfach das Django-Projekt
					    in jedem dieser Systeme klonen und die gleichen Kommandos in jedem ausprobieren.
						<ul>
							<li><code>git clone git://github.com/brosner/django.git dj-git</code></li>
							<li><code>hg clone http://hg.dpaste.com/django/trunk dj-hg</code></li>
							<li><code>bzr branch lp:django dj-bzr</code></li>
							<li><code>svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn</code></li>
						</ul>
					</div>
					
				</div>
					
					
		</div>
	
		  <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
					</div>
			
			<h2>
		  <a name="git-is-small" href="#git-is-small">Git is Small</a>
			</h2>
	
					<div class="contents">
						<div class="text">
							Git is really good at conserving space.	 Your Git directory will 
							(in general) barely be larger than an SVN checkout - in some cases
							actually smaller (apparently a lot can go in those .svn dirs).
						</div>
					
						<div class="text">
							The following numbers were taken from clones of the Django project
							in each of its semi-official Git mirrors at the same point in 
							its history.
						</div>
					
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
								<th>Bzr*</th>
								<th>SVN</th>
							</tr>
							<tr>
								<td>Repo Alone</td>
								<td class="sweet">24M</td>
								<td>34M</td>
								<td>45M</td>
								<td>89M</td>
								<td></td>
							</tr>
							<tr>
								<td>Entire Directory</td>
								<td class="compare">43M</td>
								<td>53M</td>
								<td>64M</td>
								<td>108M</td>
								<td class="compare">61M</td>
							</tr>
						</table>
						
						<div class="text"><small>
							* the second Bzr number is after I ran 'bzr pack', which I thought
							would make it smaller, but ended up making it much, much larger for
							some reason. 
						</small></div>
						
					</div>
		</div>

		<div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
		
			<h2>
		  <a name="the-staging-area" href="#the-staging-area">The Staging Area</a>
			</h2>
					<div class="contents">
						<div class="text">
							Unlike the other systems, Git has what it calls the "staging area"
							or "index".	 This is an intermediate area that you can setup what
							you want your commit to look like before you commit it.
						</div>
						<div class="text">
							The cool thing about the staging area, and what sets Git apart 
							from all these other tools, is that you can easily stage some of
							your files as you finish them and then commit them without commiting
							all the modified files in your working directory, or having to list
							them on the command line during the commit
						</div>
						<center><img src="images/index1.png"></center>
						
						<div class="text">
							This also allows you to stage parts of files that have been modified,
							for example to only stage for commit the changes at the top of the
							file you've been hacking on, but not the bottom changes.
						</div>

						<div class="text">
							Of course, Git also makes it pretty easy to ignore this feature
							if you don't want that kind of control - just slap a '-a' to your
							commit command.
						</div>
						
						<center><img src="images/index2.png"></center>
					</div>
		</div>

		<div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

			<h2>
		  <a name="distributed" href="#distributed">Distributed</a>
			</h2>

					<div class="contents">

					  <div class="text">
						One of the coolest features of any of the Distributed SCMs, Git included, is that it's
						distributed.	This means that instead of doing a "checkout" of the current tip of 
						the source code, you do a "clone" of the entire reposititory.	 
					  </div>
					  <div class="text">
						This means that even 
						if you're using a centralized workflow, every user has what is essentially a full
						backup of the main server, each of which could be pushed up to replace the main server
						in the event of a crash or corruption.	There is basically no single point of failure
						with Git unless there is only a single point.
					  </div>
					  
					  <div class="text">
						This does not slow things down much, either.	On average, an SVN checkout is faster than
						any of the DSCMs, but not by too much. Furthermore, of the DSCMs, Git was the fastest
						in my tests.
					  </div>

						<table>
							<tr><td>
								<img src="http://chart.apis.google.com/chart?cht=bvs&chs=200x150&chd=t:120,144,311,64&chds=0,320&chco=4d89f9&chl=git|hg|bzr|svn&chtt=Clone">
							</td><td width="80%">
								<table>
									<tr>
										<th>Git</th>
										<td class="sweet">1m 59s</td>
									</tr>
									<tr>
										<th>Hg</th>
										<td>2m 24s</td>
									</tr>
									<tr>
										<th>Bzr</th>
										<td>5m 11s</td>
									</tr>
									<tr>
										<th>SVN</th>
										<td>1m 4s</td>
									</tr>
								</table>
							</td></tr>
						</table>
						
					</div>
		</div>
	
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>
		
		<h2>
		<a name="any-workflow" href="#any-workflow">Any Workflow</a>
		</h2>

				<div class="contents">
					
					<div class="text">
						One of the amazing things about Git is that because of its distributed
						nature and super branching system, you can easily implement pretty
						much any workflow you can think of relatively easily.
					</div>
					
					<h3>Subversion-Style Workflow</h3>
					

					<div class="text">
						A very common Git workflow, especially from people transitioning
						from a centralized system, is a centralized workflow.  Git will 
						not allow you to push if someone has pushed since the last time
						you fetched, so a centralized model where all developers push to
						the same server works just fine.
					</div>
					
					<center><img src="images/workflow-a.png"></center><br/>
					
					<h3>Integration Manager Workflow</h3>

					<div class="text">
						Another common Git workflow is where there is an integration 
						manager - a single person who commits to the 'blessed' repository,
						and then a number of developers who clone from that repository, 
						push to their own independant repositories and ask the integrator
						to pull in their changes.  This is the type of development model 
						you often see with open source or GitHub repositories.
					</div>

					<center><img src="images/workflow-b.png"></center><br/>

					<h3>Dictator and Lieutenants Workflow</h3>

					<div class="text">
						For more massive projects, you can setup your developers similar to
						the way the Linux kernel is run, where people are in charge of a
						specific subsystem of the project ('lieutenants') and merge in all
						changes that have to do with that subsystem.  Then another integrator
						(the 'dictator') can pull changes from only his/her lieutenants and
						the push to the 'blessed' repository that everyone then clones from
						again.
					</div>

					<center><img src="images/workflow-c.png"></center><br/>
					
					<div class="text">
						Again, Git is entirely flexible about this, so you can mix and 
						match and choose the workflow that is right for you. 
					</div>
					
				</div>
		</div>
	
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang hg">hg</span>
					<span class="lang bzr">bzr</span>
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>

		<h2>
		<a name="github" href="#github">GitHub</a>
		</h2>
				
				<div class="contents">

					<img style="float:right; padding:10px" src="images/octocat.png">

					<div class="text">
						I <em>may</em> be biased here, being as how I work for 
						<a href="http://github.com">GitHub</a>, 
						but I add this section anyway because so many people say that
						GitHub itself was specifically why they choose Git.
					</div>

					<div class="text">					
						GitHub is a reason to use Git for many people because it is more 
						like a social network for code than a simple hosting site.	People
						find other developers or projects that are similar to the things
						they are doing, and can easily fork and contribute, creating a very
						vibrant community around Git and the projects that people use it
						for.
					</div>
					
					<div class="text">					
						There exist other services, both for Git and for the other SCMs,
						but few are user-oriented or socially
						targeted, and none have anywhere near the user-base.  
						This social aspect of GitHub is killer, and this plus all of the above features
						make working with Git and GitHub a great combination for rapidly 
						developing open source projects.
					</div>

					<div class="text">					
						This type of community is simply not available in any of the other
						SCMs.
					</div>
					
					<div class="tweets">
						<img alt='puls twitter' width="300" src="http://twictur.es/i/1022858126.gif">
						<img alt='twitter' width="300" src="http://twictur.es/i/1022857633.gif">
					</div>
				</div>
		</div>
	
	
			<!-- 
				OTHER IDEAS:
				* easy merging
				* easy server setup
				* non destructive
			-->

	
			<!-- GIT MYTHS -->
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang perforce">perforce</span>
				</div>
				
		<h2>
		<a name="easy-to-learn" href="#easy-to-learn">Easy to Learn</a>
		</h2>
		
				<div class="contents">
					<div class="text">										
						This did not used to be true - early in Git's life, it was not really 
						an SCM so much as a bunch of tools that let you do versioned filesystem 
						work in a distributed manner.  However, today, the command set and 
						learning curve of Git are pretty similar to any other SCM, and even 
						better than some.
					</div>

					<div class="text">										
						Since this is difficult to prove objectively without some sort of 
						study, I'll just show the difference between the default 'help' menu for the
						Mercurial and Git commands.	 I've highlighted the commands that are
						identical (or nearly) between the two systems.	(In Hg, if you type 'hg help', you 
						get a list of 40-some commands.)
					</div>
				
					<table class="help">
						<tr><td valign="top">
							
<h3>Mercurial Help</h3>
<pre>
<span class="compare">add</span>		add the specified files ...
<span class="compare">annotate</span>	show changeset informati...
<span class="compare">clone</span>		make a copy of an existi...
<span class="compare">commit</span>		commit the specified fil...
<span class="compare">diff</span>		diff repository (or sele...
export	   dump the header and diff...
<span class="compare">init</span>		create a new repository ...
<span class="compare">log</span>		show revision history of...
<span class="compare">merge</span>		merge working directory ...
parents	   show the parents of the ...
<span class="compare">pull</span>		pull changes from the sp...
<span class="compare">push</span>		push changes to the spec...
<span class="compare">remove</span>		remove the specified fil...
serve	   export the repository vi...
<span class="compare">status</span>		show changed files in th...
update	   update working directory
</pre>

					</td><td valign="top">
						
<h3>Git Help</h3>
<pre>
<span class="compare">add</span>		Add file contents to the index
<span class="compare">bisect</span>		Find the change that introduce...
<span class="compare">branch</span>		List, create, or delete branches
checkout   Checkout a branch or paths to ...
<span class="compare">clone</span>		Clone a repository into a new ...
<span class="compare">commit</span>		Record changes to the repository
<span class="compare">diff</span>		Show changes between commits, ...
fetch	   Download objects and refs from...
grep	   Print lines matching a pattern
<span class="compare">init</span>		Create an empty git repository
<span class="compare">log</span>		Show commit logs
<span class="compare">merge</span>		Join two or more development h...
mv		   Move or rename a file, a direc...
<span class="compare">pull</span>		Fetch from and merge with anot...
<span class="compare">push</span>		Update remote refs along with ...
rebase	   Forward-port local commits to ...
reset	   Reset current HEAD to the spec...
<span class="compare">rm</span>			Remove files from the working ...
show	   Show various types of objects
<span class="compare">status</span>		Show the working tree status
<span class="compare">tag</span>		Create, list, delete or verify...
</pre>	
				</td></tr>
				</table>
				
				<div class="text">										
					Prior to Git 1.6, all of the Git commands used to be in the executable
					path, which was very confusing to people.  Although Git still recognizes
					all of those commands, the only command in the path is now 'git'.
					So, if you look at Mercurial and Git, Git has a nearly identical 
					command set and help system - there is very little difference from 
					a beginning UI perspective today.
				</div>
				
				<div class="text">										
					These days it's pretty hard to argue that Mercurial or Bazaar is any
					easier to learn than Git is.
				</div>
				
				</div>
				
		</div>
	
	
		<!-- 
			THINGS GIT IS STILL NOT GOOD AT 
			* windows (all)
			* large files (svn)
		-->

		<br/>
		
	<div class="span-24 footer">
			This site is built and maintained by <a href="http://github.com/schacon">Scott Chacon</a>, a <a href="http://github.com">GitHubber</a>.<br/>
			If you disagree with
			anything on the site and you have a good reason, please 
			<a href="mailto:schacon@gmail.com">email me</a> so I can fix it.<br/>
			The source for this site is <a href="http://github.com/schacon/whygitisbetter">on GitHub</a> - feel free to send patches if you want to improve it.
		</div>

	</div>

<script>
	$(function() {
		$('.section > .contents').hide();
		$('.contents > .tweets').hide();
		$('.section > h2').click(function() {
			$(this).next().slideToggle();
		})
		
		if (document.location.hash) {
		  $('.section > h2 > a[name=' + document.location.hash.substring(1) + ']').parent('h2').click()
		}
	})
</script>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-82337-13");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

