<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Warum Git besser als X ist</title>
	
	<link rel="stylesheet" href="blueprint/screen.css" type="text/css" media="screen, projection">
	<link rel="stylesheet" href="blueprint/print.css" type="text/css" media="print">
	<!--[if IE]><link rel="stylesheet" href="blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"></script>
  <script src="javascripts/main.js" type="text/javascript"></script>
	
	<style type="text/css">
		html { overflow-y: scroll; }
		.header h1 { font-size: 3.5em; color: #666; }
		.expand_collapse_links { text-align: center; }
		.expand_collapse_links a { color: #555; }
		img { margin-bottom: 10px; }
		.text, p { font-size: 1.2em; margin-bottom: 10px; text-align: justify;}
		.intro { color: #444; }
		ul li { margin-top: 10px; }
		.section h2 { padding-left: 5px; background-color: #eee; cursor: pointer;}
		.section h2 a { color: #333; text-decoration:none; display: block; }
		.section { margin-bottom: 20px; }
		.contents { padding: 0 10px; }
		.args { float:right; }
		.lang { padding: 3px; font-weight: bold;}
		.section .lang { font-size: 0.8em; padding: 2px; font-weight: normal;}
		.svn { color: hsl(260,57%,24%); background: hsl(260,57%,83%) }
		.perforce { color: hsl(0,57%,24%); background: hsl(0,57%,83%) }
		.bzr { color: hsl(60,57%,24%); background: hsl(60,57%,83%) }
		.hg { color: hsl(190,57%,24%); background: hsl(190,57%,83%) }
		.sweet { color: #363; background: #beb; }
		.compare { color: #663; background: #eeb; }
		.help pre { font-size: 12px; }
		.help td { vertical-align: top; }
		code { font-size: 90%; }
		.footer { text-align: center; color: #663; background-color: #eea; padding: 10px;}
		.footer a { color: #440; }
	</style>
	
</head>

<body>

	<div class="container">

			<br/>
			
		<div class="span-24 header">
				<table width="100%">
					<tr><td>
	        <h1>Warum Git besser als X ist</h1>
					</td><td align="right">
						<div id="menu">
							<span class="lang hg">hg</span>
							<span class="lang bzr">bzr</span>
							<span class="lang svn">svn</span>
							<span class="lang perforce">perforce</span>
						</div>
						<img style="float: right" src="images/wherex.gif">
					</td></tr>
					</table>
		</div>

		<div class="span-24">
					<div class="text intro">
					    Diese Seite existiert weil ich in letzter Zeit oft Gitster gegen
					    Vorw&uuml;rfe von Fanboyismus, Mitl&auml;ufertum und "koolaid-Durst" verteidigen
					    musste. Darum hab ich eine Liste mit Gr&uuml;nden zusammengestellt
					    weshalb Leute von X zu Git wechseln und warum du vielleicht auch wechseln
					    willst. Klicke einfach auf einen Grund um ihn anzuschauen.
					</div>
					
					<div class="expand_collapse_links" style="display: none;">
					  <a href="#" class="expand_all">Alle ausklappen</a> |
					  <a href="#" class="collapse_all">Alle einklappen</a>
					</div>
	    </div>

			<br/>

		<div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

			<h2>
		  <a name="cheap-local-branching" href="#cheap-local-branching">Leichtgewichtige lokale Branches</a>
			</h2>
					<div class="contents">
						
						<div class="text">
						    Eines der wahrscheinlich verlockendsten Features von Git,
						    welches es auch von so ziemlich allen anderen SCMs abhebt.
						    Es unterscheidet sich komplett von den anderen Modellen mit denen
						    ich es hier vergleiche, bei denen meistens ein kompletter Klon des
						    Repositories in einem neuen Verzeichnis als beste Branching-Strategie
						    empfohlen wird.
						</div>
						
						<div class="text">
						    Git arbeitet anders. Git erlaubt es dir mehrere lokale Branches
						    zu haben, die voneinander komplett unabh&auml;ngig sein k&ouml;nnen.
						    Erzeugen, Zusammenf&uuml;hren und L&ouml;schen von diesen Entwicklungsstr&auml;ngen
						    geht schnell vonstatten.
						</div>
						
						
						<div class="text">
						    Dadurch kann man Dinge machen wie:
							<ul>
								<li>Eine Idee in einem eigenen Branch ausprobieren, ein paar Commits
								    machen, zum Ursprungsbranch zur&uuml;ck wechseln, einen Patch einspielen,
								    wieder zum Ideenbranch wechseln und ihn dann mergen.
								</li>
								<li>Einen Branch haben der alles beinhaltet was in Produktion gehen
								    soll, einen wo man neue Features zum Austesten einspielt und
								    viele kleinere f&uuml;r die t&auml;gliche Arbeit.
								</li>
								<li>F&uuml;r jedes neue Feature an dem du arbeitest einen eigenen
								    Branch erzeugen, damit du nahtlos zwischen ihnen wechseln
								    kannst, ohne dass sich die Branches ins Gehege kommen
								    und sie dann einfach zu l&ouml;schen wenn sie in den Hauptbranch
								    eingespielt wurden.
								</li>
								<li>Ein Experiment in einem Branch ausprobieren, entdecken dass es
								    nicht funktioniert und den Branch einfach l&ouml;schen &mdash; ohne dass jemand
								    anders diesen Branch jemals zu Gesicht bekommt (auch wenn du
								    in der Zwischenzeit andere Branches gepusht hast).
								</li>
							</ul>
						</div>
						
						<img src="images/branches.png">
						
						<div class="text">
						    Wichtig: Wenn du zu einem entfernten Repository pushst, musst du
						    <em>nicht</em> alle deine lokalen Branches pushen. Du kannst auch
						    nur einen Branch ver&ouml;ffentlichen, und die anderen lokal lassen.
						    Das gibt dir die Freiheit neue Ideen auszuprobieren ohne dir
						    dar&uuml;ber Gedanken zu machen wie und wo du sie mit anderen Branches
						    zusammenf&uuml;hrst oder sie mit anderen Leuten teilst.
						</div>
						
						<div class="text">
						    Du <em>kannst</em> Wege finden all das auch mit anderen Systemen zu machen,
						    aber das bedeutet meistens mehr Arbeit und h&ouml;here Fehleranf&auml;lligkeit. Git
						    macht diesen Prozess unglaublich einfach, was die Arbeitsweise
						    der meisten Entwickler &auml;ndert wenn sie Git lernen.
						</div>
						
						<!-- TODO : (short screencast showing the awesomeness of git branches) -->
						<!-- TODO : (show tweets somehow) -->

						<div class="tweets">
							<img alt='jamis twitter' width="300" src="http://twictur.es/i/1022811017.gif">
							<img alt='trevorturk twitter' width="300" src="http://twictur.es/i/1022886570.gif">
							<img alt='thillerson twitter' width="300" src="http://twictur.es/i/1022842917.gif">
							<img alt='boblmartens twitter' width="300" src="http://twictur.es/i/1022818467.gif">
							<img alt='mathie twitter' width="300" src="http://twictur.es/i/1022816942.gif">
						</div>
					</div>
		</div>
				
		<div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			<h2>
				<a name="everything-is-local" href="#everything-is-local">Alles ist lokal</a>
			</h2>
					<div class="contents">	

						<div class="text">
						    Grunds&auml;tzlich arbeiten alle dezentralen SCMs lokal, aber
						    nach meiner Erfahrung ist das bei Git noch viel mehr der Fall.
						    Nur wenige Kommandos ausser 'fetch', 'pull' und 'push'
						    nehmen mit der Aussenwelt Kontakt auf, meistens wird nur
						    die Festplatte beansprucht.
						</div>

						<div class="text">
						    Das macht nicht nur die meisten Operationen um einiges schneller
						    als du es vielleicht gew&ouml;hnt bist, aber es erlaubt dir auch
						    komplett offline zu arbeiten. Das klingt jetzt vielleicht nicht
						    sehr aufregend, aber ich bin immer wieder erstaunt wie oft ich
						    eigentlich offline arbeiten muss. Die F&auml;higkeit neue Branches
						    anlegen oder zusammenf&uuml;hren zu k&ouml;nnen oder die History des
						    Projektes anzusehen w&auml;hrend ich im Flugzeug oder im Zug sitze
						    ist sehr praktisch.
						</div>
						
						<center><img width="500px" src="images/local-remote.png"></center>

						<div class="text">
						    Selbst in Mercurial nehmen oft genutzte Kommandos wie 'incoming'
						    und 'outgoing' Kontakt mit dem Server auf, w&auml;hrend man in Git mit
						    einem 'fetch' alle Daten holen kann bevor man offline geht und
						    dann Vergleiche, Merges oder History mit den Daten macht,
						    die schon auf dem Server sind aber noch nicht in den lokalen Branches.
						</div>
												
						<div class="text">
						    Das bedeutet dass es sehr einfach ist Kopien nicht nur von
						    den eigenen Branches zu haben, sondern auch denen von jedem
						    anderen der mit dir im Git-Repository arbeitet, ohne dass
						    du dein eigenes Zeug durcheinander bringen musst.
						</div>
						
					</div>
		</div>
		
		  <div class="span-24 section">
					<div class="args">
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			
			<h2>
		  <a name="git-is-fast" href="#git-is-fast">Git ist Schnell</a>
			</h2>
	
					<div class="contents">
						<div class="text">
						    Git ist schnell. Jeder, selbst Hardcore-Benutzer anderer SCMs,
						    geben generell Git diesen Titel. Verglichen mit SVN und Perforce
						    ist Git so schnell weil beinahe alle Operationen lokal passieren.
						    Aber selbst verglichen mit anderen verteilten SCMs ist Git ziemlich schnell.
						</div>
					
						<div class="text">
						    Ein Grund daf&uuml;r ist, dass Git dazu gebaut wurde um am Linux-Kernel zu
						    arbeiten, wodurch es von Beginn an effektiv mit grossen
						    Repositories umgehen musste.
						    Ein anderer Grund ist, dass Git in C geschrieben ist und noch
						    ein weiterer Grund ist, dass die prim&auml;ren Entwickler in meiner
						    Erfahrung sich sehr, sehr genau damit besch&auml;ftigen.
						</div>

						<div class="text">
						    Im folgenden sind ein paar Benchmarks die ich mit drei Kopien
						    des Django Sourcecodes in 3 verschiedenen SCMs gemacht habe:
						    Git, Mercurial und Bazaar. Ich hab einiges von dem auch in SVN
						    getestet, aber glaub mir, es ist langsamer &mdash; nimm die Zahlen von
						    Bazaar und f&uuml;ge Netzwerklatenz hinzu...
						</div>
						
						<table>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:2,5,60&amp;chds=0,60&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Init">

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:85,3,23&amp;chds=0,100&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Add">

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:45,194,1474&amp;chds=0,1474&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Status">
						
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,21,142&amp;chds=0,142&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Diff">
						</td><td rowspan="2">
							<img src="http://chart.apis.google.com/chart?cht=bvg&amp;chs=190x275&amp;chd=t:1,123,390|11,946,820&amp;chds=0,1210&amp;chxt=x&amp;chco=4d89f9,c6d9fd&amp;chl=git|hg|bzr&amp;chtt=Branching">
						</td></tr>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,120,189&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Tag">

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:7,26,90&amp;chds=0,90&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Log">

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:124,125,230&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit (Lg)">

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:8,51,113&amp;chds=0,113&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit (Sm)">
						</td></tr>
						</table>
						
						<div class="text">
						    Das Endresultat war, dass Git in allem ausser dem Hinzuf&uuml;gen von neuen
						    Dateien am schnellsten war (Mercurial liegt bei sehr grossen Commits
						    gleichauf, aber der Commit mit dem ich getestet habe war so gross dass
						    es unwahrscheinlich ist dass du jemals etwas &auml;hnlich grosses
						    comitten wirst &mdash; normale Commits sind viel schneller in Git)
						</div>
						
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
							</tr>
							<tr>
								<th>Init</th>
								<td class="sweet">0.024s</td>
								<td>0.059s</td>
								<td>0.600s</td>
							</tr>
							<tr>
								<th>Add</th>
								<td>8.535s</td>
								<td class="sweet">0.368s</td>
								<td>2.381s</td>
							</tr>
							<tr>
								<th>Status</th>
								<td class="sweet">0.451s</td>
								<td>1.946s</td>
								<td>14.744s</td>
							</tr>
							<tr>
								<th>Diff</th>
								<td class="sweet">0.543s</td>
								<td>2.189s</td>
								<td>14.248s</td>
							</tr>
							<tr>
								<th>Tag</th>
								<td class="sweet">0.056s</td>
								<td>1.201s</td>
								<td>1.892s</td>
							</tr>
							<tr>
								<th>Log</th>
								<td class="sweet">0.711s</td>
								<td>2.650s</td>
								<td>9.055s</td>
							</tr>
							<tr>
								<th>Commit (Large)</th>
								<td class="sweet">12.480s</td>
								<td>12.500s</td>
								<td>23.002s</td>
							</tr>
							<tr>
								<th>Commit (Small)</th>
								<td class="sweet">0.086s</td>
								<td>0.517s</td>
								<td>1.139s</td>
							</tr>
							<tr>
								<th>Branch (Cold)</th>
								<td class="sweet">1.161s</td>
								<td>94.681s</td>
								<td>82.249s</td>
							</tr>
							<tr>
								<th>Branch (Hot)</th>
								<td class="sweet">0.070s</td>
								<td>12.300s</td>
								<td>39.411s</td>
							</tr>
						</table>
					
						<div class="text">
						    Die kalten und warmen Branching-Werte sind die Zahlen f&uuml;r das
						    erste und das zweite erstellen eines neuen Branches -
						    die zweite Zahl ist ein neuer Branch mit einem warmen
						    Festplatten-Cache.
						</div>

						<div class="text">
						    Es sollte angemerkt werden, dass, obwohl die 'add'-Werte um einiges
						    langsamer sind, dies f&uuml;r eine wirklich massive 'add'-Operation
						    war &mdash; &uuml;ber 2000 Dateien. F&uuml;r den Großteil von dem was die meisten Leute
						    t&auml;glich machen werden sind 'add'-Operationen in allen diesen Systemen
						    innerhalb eines Bruchteils einer Sekunde erledigt. Alle anderen
						    Operationen die hier getestet wurden (ausser dem grossen Commit
						    vielleicht) sind ein Hinweis auf die Dinge die man vielleicht
						    auch t&auml;glich macht.
						</div>
					
					
					<div class="text">
					    Die Zahlen sind nicht wirklich schwer zu reproduzieren: einfach das Django-Projekt
					    in jedem dieser Systeme klonen und die gleichen Kommandos in jedem ausprobieren.
						<ul>
							<li><code>git clone git://github.com/brosner/django.git dj-git</code></li>
							<li><code>hg clone http://hg.dpaste.com/django/trunk dj-hg</code></li>
							<li><code>bzr branch lp:django dj-bzr</code></li>
							<li><code>svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn</code></li>
						</ul>
					</div>
					
				</div>
					
					
		</div>
	
		  <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
					</div>
			
			<h2>
		  <a name="git-is-small" href="#git-is-small">Git ist klein</a>
			</h2>
	
					<div class="contents">
						<div class="text">
						    Git ist wirklich gut darin Platz zu sparen. Dein Git-Verzeichnis
						    wird (im Allgemeinen) kaum gr&ouml;sser als ein SVN Checkout sein -
						    in manchen F&auml;llen sogar kleiner (anscheinend kann ganz sch&ouml;n viel in diese
						    .svn-Verzeichnisse gepackt werden).
						</div>
					
						<div class="text">
						    Die folgenden Zahlen wurden von den Klonen des Django-Projekts
						    genommen: aus jedem der semi-offiziellen gespiegelten Repositories
						    am gleichen Punkt in dessen History.
						</div>
					
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
								<th>Bzr*</th>
								<th>SVN</th>
							</tr>
							<tr>
								<td>Repo Alone</td>
								<td class="sweet">24M</td>
								<td>34M</td>
								<td>45M</td>
								<td>89M</td>
								<td></td>
							</tr>
							<tr>
								<td>Entire Directory</td>
								<td class="compare">43M</td>
								<td>53M</td>
								<td>64M</td>
								<td>108M</td>
								<td class="compare">61M</td>
							</tr>
						</table>
						
						<div class="text"><small>
						    * der zweite Bzr-Wert kam nach dem Ausf&uuml;hren von 'bzr pack' zustande,
						    nachdem ich dachte, dass es das Repository kleiner machen w&uuml;rde. Aus
								irgend einem Grund wurde es aber viel, viel gr&ouml;&szlig;er.
						</small></div>
						
					</div>
		</div>

		<div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
		
			<h2>
		  <a name="the-staging-area" href="#the-staging-area">Die Staging Area</a>
			</h2>
					<div class="contents">
						<div class="text">
						    Im Gegensatz zu anderen Systemen hat git etwas namens "Staging Area"
						    oder "Index". Das ist eine Zwischenschicht in dem du deinen
						    n&auml;chsten Commit genau so vorbereiten kannst, wie du ihn haben willst.
						</div>
						<div class="text">
						    <!-- TODO: Gute Übersetzung für "Staging Area" finden -->
						    Das coole an der Staging Area und was Git von diesen anderen
						    Werkzeugen unterscheidet ist, dass du ganz einfach nur einzelne
						    Dateien in die Staging Area geben und diese dann ganz
						    einfach committen kannst ohne die anderen modifizierten Dateien
						    in deinem Arbeitsverzeichnis mit comitten zu m&uuml;ssen. Du musst
								auch nicht jede Datei einzeln auf der Kommandozeile angeben, wenn du
						    einen Commit erstellst
						</div>
						<center><img src="images/index1.png"></center>
						
						<div class="text">
						    Das erlaubt es dir auch nur Teile der Modifikationen in die Staging
						    Area zu geben. Du kannst zum Beispiel nur die &Auml;nderungen im oberen
						    Teil der Datei an der du gerade arbeitest in die Staging Area geben,
						    aber nicht die &Auml;nderungen im unteren Teil.
						</div>

						<div class="text">
						    Git macht es nat&uuml;rlich auch einfach dieses Feature zu ignorieren
						    wenn du diese feine Kontrolle nicht ben&ouml;tigst &mdash; einfach ein '-a'
						    an das Commit-Kommando anh&auml;ngen.
						</div>
						
						<center><img src="images/index2.png"></center>
					</div>
		</div>

		<div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

			<h2>
		  <a name="distributed" href="#distributed">Verteilt</a>
			</h2>

					<div class="contents">

					  <div class="text">
					    Eines der coolsten Features eines jeden verteilten SCMs, inklusive Git, ist, dass es
					    verteilt ist. Das bedeutet dass man statt einem "checkout" des aktuellsten Stand des
					    Source Codes einen kompletten "Klon" des ganzen Repositories macht.
					  </div>
					  <div class="text">
					    Dadurch hat jeder User, selbst wenn man einen zentralisierten Arbeitsablauf verwendet,
							essentiell ein komplettes Backup des Hauptservers, von dem 
					    jedes dazu verwendet kann den Hauptserver zu ersetzen falls dieser wegen eines
					    Crashes oder Datenkorruption ausfallen sollte. Es gibt deshalb mit Git grunds&auml;tzlich
					    keinen "Single Point of Failure" mehr, ausser man hat nur einen Punkt.
					  </div>
					  
					  <div class="text">
					    Das macht es aber nicht langsamer. Im Durchschnitt ist ein SVN Checkout schneller als
					    jedes der SCMs, aber nicht um viel. Des weiteren war Git das schnellste von allen DSCMs
					    in meinen Tests.
					  </div>

						<table>
							<tr><td>
								<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=200x150&amp;chd=t:120,144,311,64&amp;chds=0,320&amp;chco=4d89f9&amp;chl=git|hg|bzr|svn&amp;chtt=Clone">
							</td><td width="80%">
								<table>
									<tr>
										<th>Git</th>
										<td class="sweet">1m 59s</td>
									</tr>
									<tr>
										<th>Hg</th>
										<td>2m 24s</td>
									</tr>
									<tr>
										<th>Bzr</th>
										<td>5m 11s</td>
									</tr>
									<tr>
										<th>SVN</th>
										<td>1m 4s</td>
									</tr>
								</table>
							</td></tr>
						</table>
						
					</div>
		</div>
	
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>
		
		<h2>
		<a name="any-workflow" href="#any-workflow">Beliebige Arbeitsabl&auml;ufe</a>
		</h2>

				<div class="contents">
					
					<div class="text">
					    Eines der erstaunlichen Dinge ist, dass man wegen Gits verteilter
					    Natur und tollen Branching-System relativ einfach
					    so ziemlich jeden beliebigen Arbeitsablauf realisieren kann den
					    man haben will.
					</div>
					
					<h3>Arbeitsablauf im Subversion-Stil</h3>
					

					<div class="text">
					    Ein sehr gebr&auml;uchlicher Arbeitsablauf in Git, insbesondere von
					    Leuten die gerade den Übergang von einem zentralisierten System
					    machen, ist der zentralisierte. Git erlaubt es dir
					    deine Commits nicht zu pushen wenn jemand anderes seit dem letzen
					    Update gepusht hat. Deshalb funktioniert das zentralisierte Modell,
							wo alle Entwickler zu einem zentralen Server pushen ohne Probleme
					</div>
					
					<center><img src="images/workflow-a.png"></center><br/>
					
					<h3>Arbeitsablauf f&uuml;r Integrationsmanager</h3>

					<div class="text">
					    Ein anderer gebr&auml;uchlicher Arbeitsablauf ist der eines
					    Integrationsmanagers &mdash; einer einzelnen Person, die
					    in ein 'geweihtes' Repository committet, von dem dann die
					    anderen Entwickler klonen, ihre &Auml;nderungen in ihre eigenen,
					    unabh&auml;ngigen Repositories pushen und dann den Manager bitten
					    ihre &Auml;nderungen zu ziehen. Diese Art von Entwicklungsmodell sieht
					    man oft in Open Source oder GitHub Repositories.
					</div>

					<center><img src="images/workflow-b.png"></center><br/>

					<h3>Arbeitsablauf im Diktator-und-Leutnant Stil</h3>

					<div class="text">
					    F&uuml;r massive Projekte empfiehlt sich ein Arbeitsablauf wie er sich
					    im Linux Kernel findet, wo jemand f&uuml;r ein gewisses Subsystem
					    verantwortlich ist ('Leutnant') und alle &Auml;nderungen, die dieses
					    Subsystem betreffen, in sein Repository mergt. Dann kann ein
					    anderer Integrator (der 'Diktator') nur von seinen Leutnants
					    &Auml;nderungen ziehen und integrieren, die er dann in sein 'geweihtes'
					    Repository pusht, von dem dann jeder andere klonen oder updaten kann.
					</div>

					<center><img src="images/workflow-c.png"></center><br/>
					
					<div class="text">
					    Git ist sehr flexibel was den gew&uuml;nschten Arbeitsablauf
					    angeht. Man kann also seinen Arbeitsablauf ganz nach seinen
					    W&uuml;nschen gestalten.
					</div>
					
				</div>
		</div>
	
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang hg">hg</span>
					<span class="lang bzr">bzr</span>
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>

		<h2>
		<a name="github" href="#github">GitHub</a>
		</h2>
				
				<div class="contents">

					<img style="float:right; padding:10px" src="images/octocat.png">

					<div class="text">
					    Ich <em>mag</em> hier parteiisch sein, weil ich f&uuml;r
					    <a href="http://github.com">GitHub</a> arbeite, aber
					    ich habe diese Sektion dennoch hinzugef&uuml;gt nachdem so
					    viele Leute GitHub als speziellen Grund angef&uuml;hrt haben
					    weshalb sie Git ausw&auml;hlten.
					</div>

					<div class="text">
					    GitHub ist ein Grund f&uuml;r viele Leute Git zu verwenden, weil es mehr
					    ein soziales Netzwerk als eine einfache Code-Hosting Seite ist.
					    Es ist leicht andere Personen oder Projekte zu finden die &auml;hnliche
					    Interessen und F&auml;higkeiten haben wie du. Diese k&ouml;nnen dann
							einfach forken und eigene &Auml;nderungen beitragen. So entsteht eine sehr
							lebhafte Gemeinschaft um Git und die Projekte in denen es verwendet wird.
					</div>
					
					<div class="text">
					    Es gibt auch andere Services f&uuml;r Git und die anderen SCMs,
					    aber wenige sind so Benuzterorientiert oder sozial ausgerichtet und keines
					    hat auch nur ann&auml;hernd so viele Benutzer. Dieser soziale Aspekt
					    von GitHub ist ein M&ouml;rderfeature und all das kombiniert mit den
							m&ouml;glichen, obigen Features macht das Arbeiten mit Git und GitHub zu
							einer gro&szlig;artigen Kombination zum schnellen Entwickeln von Open Source
							Projekten.
					</div>

					<div class="text">
					    Diese Art der Gemeinschaft findet man einfach nicht in anderen SCMs.
					</div>
					
					<div class="tweets">
						<img alt='puls twitter' width="300" src="http://twictur.es/i/1022858126.gif">
						<img alt='twitter' width="300" src="http://twictur.es/i/1022857633.gif">
					</div>
				</div>
		</div>
	
	
			<!-- 
				OTHER IDEAS:
				* easy merging
				* easy server setup
				* non destructive
			-->

	
			<!-- GIT MYTHS -->
	
		<div class="span-24 section">
				<div class="args">
					<span class="lang perforce">perforce</span>
				</div>
				
		<h2>
		<a name="easy-to-learn" href="#easy-to-learn">Einfach zu lernen</a>
		</h2>
		
				<div class="contents">
					<div class="text">
					    Dies war nicht immer wahr &mdash; in den fr&uuml;hen Lebensjahren von Git war
					    es weniger ein SCM, als mehr eine Ansammlung von Tools die es einem
					    erm&ouml;glichten mit einem versioniertem Dateisystem auf eine verteilte
					    Art und Weise zu arbeiten. Heute jedoch ist der Kommando-Satz und die
							Lernkurve von Git ziemlich &auml;hnlich zu jedem anderen SCM und sogar
							besser als manch anderes.
					</div>

					<div class="text">
					    Nachdem es schwer ist, ohne eine Studie etwas objektiv nachzuweisen,
					    zeige ich nur die Unterschiede zwischen den Standardausgaben der
					    Hilfekommandos von Mercurial und Git. Ich habe Kommandos hervorgehoben
					    die in beiden Systemen gleich oder beinahe gleich funktionieren. (In
					    Mercurial bekommt man eine Liste mit ca. 40 Kommandos wenn man
					    'hg help' tippt.)
					</div>
				
					<table class="help">
						<tr><td valign="top">
							
<h3>Mercurial Help</h3>
<pre>
<span class="compare">add</span>		add the specified files ...
<span class="compare">annotate</span>	show changeset informati...
<span class="compare">clone</span>		make a copy of an existi...
<span class="compare">commit</span>		commit the specified fil...
<span class="compare">diff</span>		diff repository (or sele...
export	   dump the header and diff...
<span class="compare">init</span>		create a new repository ...
<span class="compare">log</span>		show revision history of...
<span class="compare">merge</span>		merge working directory ...
parents	   show the parents of the ...
<span class="compare">pull</span>		pull changes from the sp...
<span class="compare">push</span>		push changes to the spec...
<span class="compare">remove</span>		remove the specified fil...
serve	   export the repository vi...
<span class="compare">status</span>		show changed files in th...
update	   update working directory
</pre>

					</td><td valign="top">
						
<h3>Git Help</h3>
<pre>
<span class="compare">add</span>		Add file contents to the index
<span class="compare">bisect</span>		Find the change that introduce...
<span class="compare">branch</span>		List, create, or delete branches
checkout   Checkout a branch or paths to ...
<span class="compare">clone</span>		Clone a repository into a new ...
<span class="compare">commit</span>		Record changes to the repository
<span class="compare">diff</span>		Show changes between commits, ...
fetch	   Download objects and refs from...
grep	   Print lines matching a pattern
<span class="compare">init</span>		Create an empty git repository
<span class="compare">log</span>		Show commit logs
<span class="compare">merge</span>		Join two or more development h...
mv		   Move or rename a file, a direc...
<span class="compare">pull</span>		Fetch from and merge with anot...
<span class="compare">push</span>		Update remote refs along with ...
rebase	   Forward-port local commits to ...
reset	   Reset current HEAD to the spec...
<span class="compare">rm</span>			Remove files from the working ...
show	   Show various types of objects
<span class="compare">status</span>		Show the working tree status
<span class="compare">tag</span>		Create, list, delete or verify...
</pre>	
				</td></tr>
				</table>
				
				<div class="text">
				    Vor Git 1.6 waren alle Git Kommandos im ausf&uuml;hrbaren Pfad, was
				    f&uuml;r einige Leute sehr verwirrend war. Obwohl Git noch immer all
				    diese Kommandos kennt, ist das einzige Kommando das noch im
				    ausf&uuml;hrbaren Pfad ist 'git'. Wenn man also Mercurial und Git
						vergleicht, sieht man, dass es einen beinahe identischen Kommando-Satz
						und ein sehr &auml;nliches Hilfe-System gibt. Es gibt also aus der
						UI-Sicht f&uuml;r einen Anf&auml;ger kaum Unterschiede.
				</div>
				
				<div class="text">
				    Heutzutage ist es ziemlich schwer zu argumentieren, dass Mercurial oder
				    Bazaar leichter zu lernen sind als Git.
				</div>
				
				</div>
				
		</div>
	
	
		<!-- 
			THINGS GIT IS STILL NOT GOOD AT 
			* windows (all)
			* large files (svn)
		-->

		<br/>

    <div class="span-24">					
				<div class="expand_collapse_links" style="display: none;">
				  <a href="#" class="expand_all">Expand all</a> |
				  <a href="#" class="collapse_all">Collapse all</a>
				</div>
    </div>
    
    <br />
		
	<div class="span-24 footer">
			Diese Seite ist von <a href="http://github.com/schacon">Scott Chacon</a> gebaut worden, einem <a href="http://github.com">GitHubber</a>.<br/>
			Übersetzung ins Deutsche durch <a href="http://github.com/cypher">Markus Prinz</a> und <a href="http://github.com/lennartkoopmann">Lennart Koopmann</a>.<br/>
			Wenn du aus gutem Grund mit irgendetwas auf dieser Seite nicht einverstanden bist, schreibe bitte eine
			<a href="mailto:schacon@gmail.com">email an mich</a> (in Englisch), damit ich es beheben kann.<br/>
			Den Sourcecode f&uuml;r diese Seite findest du <a href="http://github.com/schacon/whygitisbetter">auf GitHub</a> -
			Patches sind jederzeit Willkommen, wenn du Verbesserungen hast.
		</div>

	</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-82337-13");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

