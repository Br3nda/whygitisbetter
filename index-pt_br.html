<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Por que Git é Melhor que X</title>
	
	<link rel="stylesheet" href="blueprint/screen.css" type="text/css" media="screen, projection">
	<link rel="stylesheet" href="blueprint/print.css" type="text/css" media="print">    
	<!--[if IE]><link rel="stylesheet" href="blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"></script>
	
	<style type="text/css">
		.header h1 { font-size: 3.5em; color: #666; }
		img { margin-bottom: 10px; }
		.text, p { font-size: 1.2em; margin-bottom: 10px; text-align: justify;}
		.intro { color: #444; }
		ul li { margin-top: 10px; }
		.section h2 { padding-left: 5px; background-color: #eee; cursor: pointer;}
    .section h2 a { color: #333; text-decoration:none; display: block; }
		.section { margin-bottom: 20px; }
		.contents { padding: 0 10px; }
		.args { float:right; }
		.lang { padding: 3px; font-weight: bold;}
		.section .lang { font-size: 0.8em; padding: 2px; font-weight: normal;}
		.svn { color: hsl(260,57%,24%); background: hsl(260,57%,83%) }
		.perforce { color: hsl(0,57%,24%); background: hsl(0,57%,83%) }
		.bzr { color: hsl(60,57%,24%); background: hsl(60,57%,83%) }
		.hg { color: hsl(190,57%,24%); background: hsl(190,57%,83%) }
		.sweet { color: #363; background: #beb; }
		.compare { color: #663; background: #eeb; }
		.help pre { font-size: 12px; }
		.help td { vertical-align: top; }
		code { font-size: 90%; }
		.footer { text-align: center; color: #663; background-color: #eea; padding: 10px;}
		.footer a { color: #440; }
	</style>
	
</head>

<body>

	<div class="container">

			<br/>
			
	    <div class="span-24 header">
				<table width="100%">
					<tr><td>
        		<h1>Por que Git é Melhor que X</h1>
					</td><td align="right">
						<div id="menu">
							<span class="lang hg">hg</span>
							<span class="lang bzr">bzr</span>
							<span class="lang svn">svn</span>
							<span class="lang perforce">perforce</span>
						</div>
						<img style="float: right" src="images/wherex.gif">
					</td></tr>
					</table>
	    </div>

	    <div class="span-24">
					<div class="text intro">
						Este site está aqui porque parece que estou gastando muito tempo ultimamente
						defendendo os <em>Gitsters</em> contra acusações de fazerem parte de um mero fã-clube, de serem maria-vai-com-as-outras.
						Então, aqui está porque as pessoas estão mudando de X para Git, e 
						porque você deveria também. Basta clicar em uma razão para visualizá-la.
					</div>
	    </div>

			<br/>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="cheap-local-branching" href="#cheap-local-branching"><em>Branches</em> Locais Baratos</a>
	        </h2>
					<div class="contents">
						
						<div class="text">
							Provavelmente a funcionalidade mais atrativa do Git que realmente a torna
							diferente de praticamente todo outro SCM (<em>Source Control Management</em>) é seu
							modelo de <em>branches</em>. É completamente diferente de todos os outros modelos que
							estou comparando aqui, onde a maioria recomenda que o melhor <em>branch</em> é 
							basicamente um clone do repositório em outro diretório.
						</div>
						
						<div class="text">
							Git não funciona dessa forma. Git permite a existência de múltiplos <em>branches</em> locais
							que podem ser inteiramente independentes de cada um e a criação, <em>merges</em> e
							deleção dessas linhas de desenvolvimento leva segundos.
						</div>
						
						
						<div class="text">
							Isso significa que você pode fazer coisas como:
							<ul>
								<li>Criar um <em>branch</em> para testar uma idéia, fazer <em>commit</em> algumas vezes,
									voltar para a partir de onde você fez o <em>branch</em>, aplicar um <em>patch</em>,
									voltar para onde está experimentando, então fazer <em>merge</em>.
								</li>
								<li>Ter um <em>branch</em> que sempre contém somente o que vai para produção,
									outro onde você faz <em>merge</em> do trabalho para testar e várias outras
									menores para atividades do dia a dia.
								</li>
								<li>Criar novas <em>branches</em> para cada nova funcionalidade que estiver
									trabalhando, para que você possa mudar de uma para outra com
									facilidade, então deletar cada <em>branch</em> quando essa fizer <em>merge</em>
									dessa funcionalidade na linha principal.
								</li>
								<li>Criar um <em>branch</em> para experimentar, descobrir que não vai funcionar
									e somente deletá-la, abandonando o trabalho - sem que ninguém veja
									isso (mesmo se você tiver empurrado (<em>pushed</em>) outras <em>branches</em> no meio do 
									caminho).
								</li>
							</ul>
						</div>
						
						<img src="images/branches.png">
						
						<div class="text">
							De forma importante, quando você empurra (<em>push</em>) para um repositório remoto,
							você <em>não</em> precisa empurrar todos os seus <em>branches</em>. Você pode apenas
							compartilhar um de seus <em>branches</em> e não todos. Isso tende a liberar as pessoas
							para testar novas idéias sem se preocupar sobre ter um plano de como eles vão
							fazer <em>merge</em> ou compartilhar com os outros.
						</div>
						
						<div class="text">
							Você pode encontrar maneiras de fazer alguma coisa disso em outros
							sistemas, mas o trabalho envolvido é muito mais difícil e passível de erros.
							Git torna esse processo incrivelmente fácil e muda a maneira como a maioria
							dos desenvolvedores trabalhando quando aprendem.
						</div>
						
						<!-- TODO : (short screencast showing the awesomeness of git branches) -->
						<!-- TODO : (show tweets somehow) -->

						<div class="tweets">
							<img alt='jamis twitter' width="300" src="http://twictur.es/i/1022811017.gif">
							<img alt='trevorturk twitter' width="300" src="http://twictur.es/i/1022886570.gif">
							<img alt='thillerson twitter' width="300" src="http://twictur.es/i/1022842917.gif">
							<img alt='boblmartens twitter' width="300" src="http://twictur.es/i/1022818467.gif">
							<img alt='mathie twitter' width="300" src="http://twictur.es/i/1022816942.gif">
						</div>
					</div>
	    </div>
				
	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
	        <h2>
          <a name="everything-is-local" href="#everything-is-local">Tudo é local</a>
	        </h2>
					<div class="contents">	

						<div class="text">
							Isso é basicamente verdade de todos os SCMs distribuídos, mas em minha
							experiência muito mais com Git. Existe muito pouco fora de '<tt>fetch</tt>', '<tt>pull</tt>',
							'<tt>push</tt>' que comunica de alguma maneira com qualquer coisa além do seu disco
							rígido.
						</div>

						<div class="text">
							Isso não só faz com que a maioria das operações seja mais rápida do que você deve
							estar acostumado, mas também lhe permite trabalhar em coisas quando está 
							desconectado. Isso pode não soar grande coisa, mas eu sempre me surpreendo
							com a frequência com que eu de fato trabalho desconectado. Ser capaz de fazer
							<em>branches</em>, <em>merges</em>, <em>commits</em> e listar o histórico do seu projeto enquanto está no
							avião ou trem é muito produtivo.
						</div>
						
						<center><img width="500px" src="images/local-remote.png"></center>

						<div class="text">
							Mesmo no Mercurial, comandos comuns como '<tt>incoming</tt>' e '<tt>outgoing</tt>' conectam
							ao servidor, enquanto com o Git você pode fazer '<tt>fetch</tt>' de todos os dados dos
							servidores antes de se desconectar e fazer comparações, <em>merges</em> e <em>logs</em> de
							dados que estão no servidor mas não nos seus <em>branches</em> locais ainda.
						</div>
												
						<div class="text">
							Isso significa que é muito fácil ter cópias não somente de seus <em>branches</em>, mas
							também dos <em>branches</em> de todo mundo que está trabalhando com você em seu 
							repositório Git sem ter que bagunçar suas próprias coisas.
						</div>
						
					</div>
	    </div>
		
		  <div class="span-24 section">
					<div class="args">
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			
	        <h2>
          <a name="git-is-fast" href="#git-is-fast">Git é Rápido</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
							Git é rápido. Todo mundo, mesmo os usuários mais pesados desses outros
							sistemas geralmente dão esse título ao Git. Comparado ao SVN e Perforce
							isso é óbvio, já que todas as operações são locais. Entretando, mesmo comparado
							com outros DSCMs, Git é muito rápido.
						</div>
					
						<div class="text">
							Parte disso provavelmente é porque ele foi construído para trabalhar com a
							<em>kernel</em> do Linux, o que significa que ele teve que lidar efetivamente
							com repositórios enormes desde o primeiro dia.
							
							Outra razão é que o Git é escrito em C, e ainda outra razão é que os
							desenvolvedores principais são, por minha experiência, muito muito 
							preocupados com isso.
						</div>

						<div class="text">
							A seguir vários <em>benchmarks</em> que eu rodei em 3 cópias do código fonte do
							repositório do Django em 3 diferentes SCMs: Git, Mercurial e Bazaar. Eu
							também testei algumas dessas coisas no SVN, mas acredite, é muito lento -
							basicamente pegue os números do Bazaar e adicione a latência da rede...
						</div>
						
						<table>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:2,5,60&chds=0,60&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Init">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:85,3,23&chds=0,100&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Add">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:45,194,1474&chds=0,1474&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Status">
						
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:5,21,142&chds=0,142&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Diff">
						</td><td rowspan="2">
							<img src="http://chart.apis.google.com/chart?cht=bvg&chs=190x275&chd=t:1,123,390|11,946,820&chds=0,1210&chxt=x&chco=4d89f9,c6d9fd&chl=git|hg|bzr&chtt=Branching">
						</td></tr>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:5,120,189&chds=0,230&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Tag">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:7,26,90&chds=0,90&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Log">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:124,125,230&chds=0,230&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Commit (Lg)">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:8,51,113&chds=0,113&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Commit (Sm)">
						</td></tr>
						</table>
						
						<div class="text">
							O resultado final é que para qualquer coisa, menos adicionar novos arquivos,
							Git foi o mais rápido. (Também em <em>commits</em> grandes, foi basicamente a mesma
							coisa que o Hg, mas o <em>commit</em> que eu testei foi tão grande que provavelmente
							ninguém fará nada parecido - em <em>commits</em> normais o Git é muito mais rápido).
						</div>
						
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
							</tr>
							<tr>
								<th>Init</th>
								<td class="sweet">0.024s</td>
								<td>0.059s</td>
								<td>0.600s</td>
							</tr>
							<tr>
								<th>Add</th>
								<td>8.535s</td>
								<td class="sweet">0.368s</td>
								<td>2.381s</td>
							</tr>
							<tr>
								<th>Status</th>
								<td class="sweet">0.451s</td>
								<td>1.946s</td>
								<td>14.744s</td>
							</tr>
							<tr>
								<th>Diff</th>
								<td class="sweet">0.543s</td>
								<td>2.189s</td>
								<td>14.248s</td>
							</tr>
							<tr>
								<th>Tag</th>
								<td class="sweet">0.056s</td>
								<td>1.201s</td>
								<td>1.892s</td>
							</tr>
							<tr>
								<th>Log</th>
								<td class="sweet">0.711s</td>
								<td>2.650s</td>
								<td>9.055s</td>
							</tr>
							<tr>
								<th>Commit (Grande)</th>
								<td class="sweet">12.480s</td>
								<td>12.500s</td>
								<td>23.002s</td>
							</tr>
							<tr>
								<th>Commit (Pequeno)</th>
								<td class="sweet">0.086s</td>
								<td>0.517s</td>
								<td>1.139s</td>
							</tr>
							<tr>
								<th>Branch (Frio)</th>
								<td class="sweet">1.161s</td>
								<td>94.681s</td>
								<td>82.249s</td>
							</tr>
							<tr>
								<th>Branch (Quente)</th>
								<td class="sweet">0.070s</td>
								<td>12.300s</td>
								<td>39.411s</td>
							</tr>
						</table>
					
						<div class="text">
							Os números de <em>branches</em> frios e quentes são números da primeira e segunda
							vez que eu fiz branch de um repo - o segundo número sendo um <em>branch</em> com um
							cache de disco quente.
						</div>

						<div class="text">
							Deve ser notado que embora os números de '<tt>add</tt>' sejam muito mais lentos,
							isso foi para uma operação enorme - mais de 2000 arquivos. Para a maioria
							das coisas que a maioria das pessoas faz no dia a dia, operações de <em>add</em>
							em qualquer desses sistemas vai tomar somente uma fração de segundo. Todas
							as outras operações testadas aqui (exceto para o grande <em>commit</em>, possivelmente)
							são mais indicativas das coisas que você realmente faz no dia a dia.
						</div>
					
					
					<div class="text">
						Esses números realmente não são difíceis de recriar, simplesmente clone o
						projeto Django em cada um dos sistemas e teste alguns dos mesmos comandos em
						cada um.
						<ul>
							<li><code>git clone git://github.com/brosner/django.git dj-git</code></li>
							<li><code>hg clone http://hg.dpaste.com/django/trunk dj-hg</code></li>
							<li><code>bzr branch lp:django dj-bzr</code></li>
							<li><code>svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn</code></li>
						</ul>
					</div>
					
				</div>
					
					
	    </div>
	
		  <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
					</div>
			
	        <h2>
          <a name="git-is-small" href="#git-is-small">Git é Pequeno</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
							Git é realmente bom em conservar espaço. Seu diretório Git vai (em geral)
							ser só um pouquinho maior que um <em>checkout</em> de SVN - em alguns casos de fato
							menor (aparentemente aqueles diretórios .svn podem ter muita coisa).
						</div>
					
						<div class="text">
							Os seguintes números foram tirados de clones do projeto Django de cada um de
							seus espelhos semi-oficiais de Git no mesmo ponto de histórico.
						</div>
					
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
								<th>Bzr*</th>
								<th>SVN</th>
							</tr>
							<tr>
								<td>Só o Repo</td>
								<td class="sweet">24M</td>
								<td>34M</td>
								<td>45M</td>
								<td>89M</td>
								<td></td>
							</tr>
							<tr>
								<td>Diretório Inteiro</td>
								<td class="compare">43M</td>
								<td>53M</td>
								<td>64M</td>
								<td>108M</td>
								<td class="compare">61M</td>
							</tr>
						</table>
						
						<div class="text"><small>
							* o segundo número de Bzr é depois de rodar '<tt>bzr pack</tt>', que eu imaginei que
							fosse torná-lo menor, mas acabou tornando-o muito, muito maior por alguma
							razão.
						</small></div>
						
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
		
	        <h2>
          <a name="the-staging-area" href="#the-staging-area">A Área de <em>Staging</em></a>
	        </h2>
					<div class="contents">
						<div class="text">
							Diferente de outros sistemas, Git tem o que se chama "área de <em>staging</em>" ou
							"<em>index</em>". Essa é uma área intermediária que você pode configurar como você 
							quer que seu <em>commit</em> fique antes de fazê-lo.
						</div>
						<div class="text">
							A parte legal essa área de <em>staging</em>, e o que separa Git de todas as outras
							ferramentas, é que você pode facilmente ir colocando seus arquivos no <em>staging</em>
							à medida que for terminando e então fazer <em>commit</em> deles sem fazer <em>commit</em> de 
							todos os arquivos modificados em seu diretório de trabalho, ou ter que 
							listá-los na linha de comando durante o <em>commit</em>.
						</div>
						<center><img src="images/index1.png"></center>
						
						<div class="text">
							Isso também permite colocar partes de arquivos no <em>staging</em> que foram modificadas,
							por exemplo para deixar para <em>commit</em> as mudanças que estão no topo do arquivo
							que está mexendo, mas não as mudanças de baixo.
						</div>

						<div class="text">
							Claro, Git torna muito fácil ignorar essa funcionalidade se você não quiser esse
							tipo de controle - apenas ponha um '-a' no seu comando de <em>commit</em>.
						</div>
						
						<center><img src="images/index2.png"></center>
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="distributed" href="#distributed">Distribuído</a>
	        </h2>

					<div class="contents">

			<div class="text">
			Uma das funcionalidades mais legais de qualquer SCM Distribuído, Git incluso, é que ele é,
			claro, distribuído. Isso significa que em vez de fazer um "<em>checkout</em>" do topo atual do código
			fonte, você faz um "clone" do repositório inteiro.
            </div>
            <div class="text">
			Isso significa que mesmo que estiver usando um fluxo de trabalho centralizado, cada usuário
			tem o que é essencialmente um <em>backup</em> completo do servidor principal, e cada qual pode ser
			empurrado para substituir o servidor principal no evento de uma queda ou corrupção dos dados.
			Basicamente não existe ponto único de falha com Git a menos que só exista um ponto.
            </div>

            <div class="text">
			Isso não torna as coisas devagar também. Na média, um <em>checkout</em> de SVN é mais rápido do que
			qualquer um dos DSCMs, mas não muito. Além disso, dos DSCMs, o Git foi o mais rápido nos
			meus testes.
					  </div>

						<table>
							<tr><td>
								<img src="http://chart.apis.google.com/chart?cht=bvs&chs=200x150&chd=t:120,144,311,64&chds=0,320&chco=4d89f9&chl=git|hg|bzr|svn&chtt=Clone">
							</td><td width="80%">
								<table>
									<tr>
										<th>Git</th>
										<td class="sweet">1m 59s</td>
									</tr>
									<tr>
										<th>Hg</th>
										<td>2m 24s</td>
									</tr>
									<tr>
										<th>Bzr</th>
										<td>5m 11s</td>
									</tr>
									<tr>
										<th>SVN</th>
										<td>1m 4s</td>
									</tr>
								</table>
							</td></tr>
						</table>
						
					</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>
		
       	<h2>
        <a name="any-workflow" href="#any-workflow">Qualquer Fluxo de Trabalho</a>
       	</h2>

				<div class="contents">
					
					<div class="text">
						Uma das coisas fantásticas sobre Git é que por ele ser distribuído por natureza
						e ter um super sistema de <em>branches</em>, você pode facilmente implementar praticamente
						qualquer fluxo de trabalho que puder pensar com facilidade.
					</div>
					
					<h3>Fluxo de Trabalho Estilo Subversion</h3>
					

					<div class="text">
						Um fluxo muito comum de Git, especialmente para pessoas transitando de um sistema
						centralizado, é um fluxo centralizado. Git não vai permitir que você de empurrar
						(<tt>push</tt>) se alguém empurrou desde a última fez que você puxou (<tt>fetch</tt>), então um 
						modelo centralizado onde todos os desenvolvedores empurrar para o mesmo servidor
						funciona perfeitamente.
					</div>
					
					<center><img src="images/workflow-a.png"></center><br/>
					
					<h3>Fluxo de Gerenciamento de Integração</h3>

					<div class="text">
						Outro fluxo comum de Git é onde existe uma gestão de integração - uma única pessoa
						que faz <tt>commit</tt> ao repositório abençoado ('<em>blessed</em>'), e vários desenvolvedores que
						fazem clone desse repositório, empurram para seus repositórios independentes e
						pedem ao integrador para puxar suas mudanças. Esse é o modelo de desenvolvimento
						que você normalmente vê com projetos <em>open source</em> ou repositórios no GitHub.
					</div>

					<center><img src="images/workflow-b.png"></center><br/>

					<h3>Fluxos de Ditador e Tenentes</h3>

					<div class="text">
						Para projetos maiores, você pode configurar seu desenvolvimento de maneira
						similar como a que a <em>kernel</em> do Linux roda, onde algumas pessoas são responsáveis por
						um sub-sistema específico do projeto (os 'tenentes') e fazem <em>merge</em> de todas as mudanças
						que tem a ver com esse sub-sistema. Então outro integrador (o 'ditador') pode 
						puxar as mudanças de seus tenentes e empurrar para o repositório 'abençoado', e
						então todos fazem clone a partir dele novamente.
					</div>

					<center><img src="images/workflow-c.png"></center><br/>
					
					<div class="text">
						Novamente, Git é inteiramente flexível sobre isso, então você pode misturar e
						comparar e encontrar o fluxo de trabalho que for melhor para você.
          </div>
					
				</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang hg">hg</span>
					<span class="lang bzr">bzr</span>
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>

        <h2>
        <a name="github" href="#github">GitHub</a>
        </h2>
				
				<div class="contents">

          <img style="float:right; padding:10px" src="images/octocat.png">

					<div class="text">
						Eu posso ser suspeito aqui, já que trabalho para o 
						<a href="http://github.com">GitHub</a>, 
						mas adicionei essa seção de qualquer forma porque muitas pessoas dizem que
						o próprio GitHub foi justamente porque escolheram Git.
					</div>

					<div class="text">		
						GitHub é uma razão para usar Git para muitas pessoas porque é mais como uma
						rede social de código do que um site de hospedagem. As pessoas encontram outros
						desenvolvedores ou projetos similares às coisas que estão fazendo, e podem
						facilmente fazer <em>forks</em> (cópias dos repositórios) e contribuir, criando uma comunidade
						muito vibrante em torno do Git e dos projetos que as pessoas usam.
					</div>
					
					<div class="text">
						Existem outros serviços, tanto para Git quanto outros SCMs, mas poucos são
						orientados a usuários ou com objetivos sociais, e nenhum tem nada perto da
						quantidade de usuários. O aspecto social do GitHub é matador, e isso se soma
						a todas as funcionalidades listadas acima, tornando trabalhar com Git e GitHub
						uma grande combinação para desenvolvimento rápido de projetos <em>open source</em>.
					</div>

					<div class="text">		
						Esse tipo de comunidade simplesmente não existe em nenhum outro tipo de SCM.
          </div>
					
					<div class="tweets">
						<img alt='puls twitter' width="300" src="http://twictur.es/i/1022858126.gif">
						<img alt='twitter' width="300" src="http://twictur.es/i/1022857633.gif">
					</div>
				</div>
	    </div>
	
	
			<!-- 
				OTHER IDEAS:
				* easy merging
				* easy server setup
				* non destructive
			-->

	
			<!-- GIT MYTHS -->
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang perforce">perforce</span>
				</div>
				
        <h2>
        <a name="easy-to-learn" href="#easy-to-learn">Fácil de Aprender</a>
        </h2>
        
				<div class="contents">
					<div class="text">										
						Isso não costumava ser verdade - quando Git era mais novo, não era bem um SCM
						mas um conjunto de ferramentas que o permitia trabalhar com um sistema de arquivos
						versionados de maneira distribuída. Entretanto, hoje, o conjunto de comandos e a
						curva de aprendizagem do Git são muito similares de qualquer outro SCM, e mesmo
						melhor que alguns.
					</div>

					<div class="text">
						Já que isso é difícil de provar de maneira objetiva sem algum tipo de estudo,
						vou somente mostrar as diferenças entre o '<tt>help</tt>' padrão do menu de comandos para
						Mercurial e Git. Eu grifei os comandos que são idênticos (ou quase) entre ambos.
						(Em Hg, se você digitar '<tt>hg help</tt>', terá uma lista de uns 40 comandos).
					</div>
				
					<table class="help">
						<tr><td valign="top">
							
<h3>Mercurial Help</h3>
<pre>
<span class="compare">add</span>        add the specified files ...
<span class="compare">annotate</span>   show changeset informati...
<span class="compare">clone</span>      make a copy of an existi...
<span class="compare">commit</span>     commit the specified fil...
<span class="compare">diff</span>       diff repository (or sele...
export     dump the header and diff...
<span class="compare">init</span>       create a new repository ...
<span class="compare">log</span>        show revision history of...
<span class="compare">merge</span>      merge working directory ...
parents    show the parents of the ...
<span class="compare">pull</span>       pull changes from the sp...
<span class="compare">push</span>       push changes to the spec...
<span class="compare">remove</span>     remove the specified fil...
serve      export the repository vi...
<span class="compare">status</span>     show changed files in th...
update     update working directory
</pre>

					</td><td valign="top">
						
<h3>Git Help</h3>
<pre>
<span class="compare">add</span>        Add file contents to the index
<span class="compare">bisect</span>     Find the change that introduce...
<span class="compare">branch</span>     List, create, or delete branches
checkout   Checkout a branch or paths to ...
<span class="compare">clone</span>      Clone a repository into a new ...
<span class="compare">commit</span>     Record changes to the repository
<span class="compare">diff</span>       Show changes between commits, ...
fetch      Download objects and refs from...
grep       Print lines matching a pattern
<span class="compare">init</span>       Create an empty git repository
<span class="compare">log</span>        Show commit logs
<span class="compare">merge</span>      Join two or more development h...
mv         Move or rename a file, a direc...
<span class="compare">pull</span>       Fetch from and merge with anot...
<span class="compare">push</span>       Update remote refs along with ...
rebase     Forward-port local commits to ...
reset      Reset current HEAD to the spec...
<span class="compare">rm</span>         Remove files from the working ...
show       Show various types of objects
<span class="compare">status</span>     Show the working tree status
<span class="compare">tag</span>        Create, list, delete or verify...
</pre>	
				</td></tr>
				</table>
				
				<div class="text">										
					Antes do Git 1.6, todos os comandos do Git costumavam ficar no mesmo caminho que todos outros executávis,
					o que era muito confuso para as pessoas. Embora o Git ainda reconheça todos eles,
					o único comando no <em>path</em> agora é 'git'. Então, se você olhar para Mercurial ou Git,
					o Git tem um conjunto de comandos e sistema de ajuda praticamente igual - existe
					muito pouca diferença do ponto de vista inicial de interface hoje.
				</div>
				
				<div class="text">										
					Atualmente é bem difícil argumentar que Mercurial ou Bazaar são mais fáceis de
					aprender do que Git.
				</div>
				
				</div>
				
	    </div>
	
	
		<!-- 
			THINGS GIT IS STILL NOT GOOD AT 
			* windows (all)
			* large files (svn)
		-->

		<br/>
		
    <div class="span-24 footer">
			Este site foi construído e é mantido por <a href="http://github.com/schacon">Scott Chacon</a>, um <a href="http://github.com">GitHubber</a>.<br/>
			Traduzido para Português do Brasil por <a href="http://www.akitaonrails.com/">Fabio Akita</a>, com algumas correções por <a href="http://lixo.org">Carlos Villela</a>
			Se você não concorda com alguma coisa neste site e tiver uma boa razão, por favor envie
			<a href="mailto:schacon@gmail.com">e-mail</a> para o Scott para ele consertar.<br/>
			As fontes deste site estão no <a href="http://github.com/schacon/whygitisbetter">GitHub</a> - sinta-se livre para enviar patches se quiser ajudar a melhorar.
		</div>

	</div>

<script>
	$(function() {
		$('.section > .contents').hide();
		$('.contents > .tweets').hide();
		$('.section > h2').click(function() {
			$(this).next().slideToggle();
		})
		
		if (document.location.hash) {
		  $('.section > h2 > a[name=' + document.location.hash.substring(1) + ']').parent('h2').click()
		}
	})
</script>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-82337-13");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

